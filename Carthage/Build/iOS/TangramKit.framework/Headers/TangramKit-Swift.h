#ifndef TARGET_OS_SIMULATOR
#include <TargetConditionals.h>
#endif
#if TARGET_OS_SIMULATOR
#if 0
#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.2.2 (swiftlang-1103.0.32.6 clang-1103.0.32.51)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="TangramKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIWindow;
@protocol NSObject;
@class UIColor;
@class UIImage;
@class UITraitCollection;
@class UITouch;
@class UIEvent;
@class NSCoder;

/// 布局视图基类，基类不支持实例化对象。在编程时我们经常会用到一些视图，这种视图只是负责将里面的子视图按照某种规则进行排列和布局，而别无其他的作用。因此我们称这种视图为容器视图或者称为布局视图。
/// 布局视图通过重载layoutSubviews方法来完成子视图的布局和排列的工作。对于每个加入到布局视图中的子视图，都会在加入时通过KVO机制监控子视图的center和bounds以及frame值的变化，每当子视图的这些属性一变化时就又会重新引发布局视图的布局动作。同时对每个视图的布局扩展属性的设置以及对布局视图的布局属性的设置都会引发布局视图的布局动作。布局视图在添加到非布局父视图时也会通过KVO机制来监控非布局父视图的frame值和bounds值，这样每当非布局父视图的尺寸变更时也会引发布局视图的布局动作。前面说的引起变动的方法就是会在KVO处理逻辑以及布局扩展属性和布局属性设置完毕后通过调用setNeedLayout来实现的，当布局视图收到setNeedLayout的请求后，会在下一个runloop中对布局视图进行重新布局而这就是通过调用layoutSubviews方法来实现的。布局视图基类只提供了更新所有子视图的位置和尺寸以及一些基础的设置，而至于如何排列和布局这些子视图则要根据应用的场景和需求来确定，因此布局基类视图提供了一个：
/// internal func tgCalcLayoutRect(_ size:CGSize, isEstimate:Bool, hasSubLayout:inout Bool!, sbs:[UIView]!, type:TGSizeClassType) ->CGSize
/// 的方法，要求派生类去重载这个方法，这样不同的派生类就可以实现不同的应用场景，这就是布局视图的核心实现机制。
/// TangramKit布局库根据实际中常见的场景实现了7种不同的布局视图派生类他们分别是：线性布局、表格布局、相对布局、框架布局、流式布局、浮动布局、路径布局。
SWIFT_CLASS("_TtC10TangramKit12TGBaseLayout")
@interface TGBaseLayout : UIView
/// 用于实现对阿拉伯国家的布局适配。对于非阿拉伯国家来说，界面布局都是默认从左到右排列。而对于阿拉伯国家来说界面布局则默认是从右往左排列。默认这个属性是NO，您可以将这个属性设置为YES，这样布局里面的所有视图都将从右到左进行排列布局。如果您需要考虑国际化布局的问题，那么您应该用tg_leading来表示头部的位置，而用tg_trailing来表示尾部的位置，这样当布局方向是LTR时那么tg_leading就表示的是左边而tg_trailing则表示的是右边；而当布局方向是RTL时那么tg_leading表示的是右边而tg_trailing则表示的是左边。如果您的界面布局不会考虑到国际化以及不需要考虑RTL时那么您可以用tg_left和tg_right来表示左右而不需要用tg_leading和tg_trailing。
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL tg_isRTL SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");)
+ (BOOL)tg_isRTL SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)setTg_isRTL:(BOOL)newValue SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)tg_updateRTL:(BOOL)isRTL inWindow:(UIWindow * _Nonnull)window SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_updateRTL(_:inWindow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图四周的内边距值。所谓内边距是指布局视图内的所有子视图离布局视图四周的边距。通过为布局视图设置内边距可以减少为所有子视图设置外边距的工作，而外边距则是指视图离父视图四周的距离。
@property (nonatomic) UIEdgeInsets tg_padding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_padding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 顶部内边距
@property (nonatomic) CGFloat tg_topPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_topPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 头部内边距，用来设置子视图离自身头部的边距值。对于LTR方向的布局来说就是指的左边内边距，而对于RTL方向的布局来说就是指的右边内边距。
@property (nonatomic) CGFloat tg_leadingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leadingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 底部内边距
@property (nonatomic) CGFloat tg_bottomPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_bottomPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 尾部内边距，用来设置子视图离自身尾部的边距值。对于LTR方向的布局来说就是指的右边内边距，而对于RTL方向的布局来说就是指的左边内边距。
@property (nonatomic) CGFloat tg_trailingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_trailingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 左边内边距。
@property (nonatomic) CGFloat tg_leftPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leftPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 右边内边距
@property (nonatomic) CGFloat tg_rightPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_rightPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置当布局的尺寸由子视图决定并且在没有子视图的情况下tg_padding的设置值是否会加入到布局的尺寸值里面。默认是true，表示当布局视图没有子视图时tg_padding值也会加入到尺寸里面。
/// 举例来说假设某个布局视图的高度是.wrap,并且设置了tg_topPadding为10，tg_bottomPadding为20。那么默认情况下当没有任何子视图时布局视图的高度是30；而当我们将这个属性设置为false时，那么在没有任何子视图时布局视图的高度就是0，也就是说tg_padding不会参与高度的计算了。
@property (nonatomic) BOOL tg_zeroPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_zeroPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 指定padding内边距的缩进是在SafeArea基础之上进行的。默认是.all表示四周都会缩进SafeArea所指定的区域。你也可以设置只缩进某一个或则几个方向，或者不缩进任何一个方向。这个属性是为了支持iPoneX而设置的。为了支持iPhoneX的全屏幕适配。我们只需要对根布局视图设置这个扩展属性，默认情况下是不需要进行特殊设置的，TangramKit自动会对iPhoneX进行适配。我们知道iOS11中引入了安全区域的概念，TangramKit中的根布局视图会自动将安全区域叠加到设置的padding中去。默认情况下左右的安全区域都会叠加到padding中去，因此您可以根据特殊情况来设置只需要叠加哪一个方向的安全区域。
@property (nonatomic) UIRectEdge tg_insetsPaddingFromSafeArea SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetsPaddingFromSafeArea' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *当tg_insetsPaddingFromSafeArea同时设置有左右方向同时缩进并且在横屏时是否只缩进有刘海方向的内边距。默认是false，表示两边都会缩进。如果你想让没有刘海的那一边延伸到屏幕的安全区外，请将这个属性设置为true。iPhoneX设备中具有一个尺寸为44的刘海区域。当您横屏时为了对齐，左右两边的安全缩进区域都是44。但是有些时候我们希望没有刘海的那一边不需要缩进对齐而是延伸到安全区域以外。这时候您可以通过给根布局视图设置这个属性来达到效果。注意这个属性只有tg_insetsPaddingFromSafeArea设置了左右都缩进时才有效。
@property (nonatomic) BOOL tg_insetLandscapeFringePadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetLandscapeFringePadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的间距，所谓间距就是子视图之间的间隔距离。
@property (nonatomic) CGFloat tg_space SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_space' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的上下垂直间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_vspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_vspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的左右水平间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_hspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_hspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 布局里面的所有子视图按添加的顺序逆序进行布局。默认是false，表示按子视图添加的顺序排列。比如一个垂直线性布局依次添加A,B,C三个子视图，那么在布局时则A,B,C从上到下依次排列。当这个属性设置为YES时，则布局时C,B,A依次从上到下排列。
@property (nonatomic) BOOL tg_reverseLayout SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_reverseLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGAffineTransform tg_layoutTransform SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_layoutTransform' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在布局视图进行布局时是否调用基类的layoutSubviews方法，默认设置为false。
@property (nonatomic) BOOL tg_priorAutoresizingMask SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_priorAutoresizingMask' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回当前布局视图是否正在执行布局。
@property (nonatomic, readonly) BOOL tg_isLayouting SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isLayouting' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置是否选中状态。您可以用这个状态来记录布局的扩展属性。
@property (nonatomic) BOOL isSelected SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.isSelected' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除所有子视图
- (void)tg_removeAllSubviews SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_removeAllSubviews()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 执行布局动画。在布局视图的某个子视图设置完布局属性后，调用布局的这个方法可以让布局里面的子视图在布局时实现动画效果。
/// \param duration 动画时长
///
- (void)tg_layoutAnimationWithDuration:(NSTimeInterval)duration SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_layoutAnimationWithDuration(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 是否缓存经过tg_sizeThatFits方法评估后的所有子视图的位置和尺寸一次!，默认设置为false不缓存。当我们用tg_sizeThatFits方法评估布局视图的尺寸后，所有子视图都会生成评估的位置和尺寸，因为此时并没有执行布局所以子视图并没有真实的更新frame值。而当布局视图要进行真实布局时又会重新计算所有子视图的位置和尺寸，因此为了优化性能当我们对布局进行评估后在下次真实布局时我们可以不再重新计算子视图的位置和尺寸而是用前面评估的值来设置位置和尺寸。这个属性设置为true时则每次评估后到下一次布局时不会再重新计算子视图的布局了，而是用评估值来布局子视图的位置和尺寸。而当这个属性设置为false时则每次布局都会重新计算子视图的位置和布局。
/// 这个属性一般用在那些动态高度UITableviewCell中进行配合使用，我们一般将布局视图作为UITableviewCell的contentView的子视图:
/// let rootLayout= TGXXXLayout()
/// rootLayout.tg_cacheEstimatedRect = true   //设置缓存评估的rect,如果您的cell是高度自适应的话，强烈建立打开这个属性，这会大大的增强您的tableview的性能！！
/// rootLayout.tg_width.equal(.fill)           //宽度和父视图相等
/// rootLayout.tg_height.equal(.wrap)    //高度动态包裹。
/// self.contentView.addSubview(rootLayout)
/// self.rootLayout = rootLayout;
/// //在rootLayout添加子视图。。。
/// <hr/>
/// 然后我们在heightForRowAtIndexPath中按如下格式进行高度的评估的计算。
/// override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
/// let cell = self.tableView(tableView,cellForRowAt:indexPath) as! UIXXXTableViewCell
/// let size = cell.rootLayout.tg_sizeThatFits(CGSize(width:tableView.frame.width, height:0))
/// return size.height;
/// }
/// 这个属性有可能会造成动态高度计算不正确，请只在UITableviewCell的高度为自适应时使用，其他地方不建议设置这个属性！！
@property (nonatomic) BOOL tg_cacheEstimatedRect SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_cacheEstimatedRect' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 评估计算一个未加入到布局视图中的子视图subview在加入后的frame值。在实践中我们希望得到某个未加入的子视图在添加到布局视图后的应该具有的frame值，这时候就可以用这个方法来获取。比如我们希望把一个子视图从一个布局视图里面移到另外一个布局视图的末尾时希望能够提供动画效果,这时候就可以通过这个方法来得到加入后的子视图的位置和尺寸。
/// 这个方法只有针对那些通过添加顺序进行约束的布局视图才有意义，相对布局和框架布局则没有意义。
/// 使用示例：假设存在两个布局视图L1,L2他们的父视图是S，现在要实现将L1中的任意一个子视图A移动到L2的末尾中去，而且要带动画效果，那么代码如下：
/// //得到A在S中的frame，这里需要进行坐标转换为S在中的frame
/// let rectOld = L1.convert(A.frame, to: S)
/// //得到将A加入到L2后的评估的frame值，注意这时候A还没有加入到L2。
/// var rectNew = L2.tg_estimatedFrame(of: A)
/// rectNew = L2.convert(rectNew, to: S) //将新位置的评估的frame值，这里需要进行坐标转换为S在中的frame。
/// //动画的过程是先将A作为S的子视图进行位置的调整后再加入到L2中去
/// A.removeFromSuperview()
/// A.frame = rectOld
/// A.tg_useFrame = true  //设置为true表示A不再受到布局视图的约束，而是可以自由设置frame值。
/// S.addSubview(sender)
/// UIView.animate(withDuration: 0.3, animations: {
/// A.frame = rectNew
/// }) { _ in
/// //动画结束后再将A移植到L2中。
/// A.removeFromSuperview()
/// A.tg_useFrame = false  //还原tg_useFrame，因为加入到L2后将受到布局视图的约束。
/// L2.addSubview(A)
/// }
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     subview: 一个未加入布局视图的子视图，如果子视图已经加入则直接返回子视图的frame值。
///   </li>
///   <li>
///     size:指定布局视图期望的宽度或者高度，一般请将这个值设置为.zero。 具体请参考tg_sizeThatFits方法中的size的说明。
///   </li>
/// </ul>
///
/// returns:
/// 子视图在布局视图最后一个位置(假如加入后)的frame值。
- (CGRect)tg_estimatedFrameOf:(UIView * _Nonnull)subview inLayoutSize:(CGSize)size SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_estimatedFrame(of:inLayoutSize:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在布局开始之前和布局完成之后的处理块。系统会在每次布局完成前后分别执行对应的处理块后将处理块清空为nil。您也可以在tg_endLayoutDo块内取到所有子视图真实布局后的frame值。系统会在调用layoutSubviews方法前执行tg_beginLayoutDo，而在layoutSubviews方法执行后执行tg_endLayoutDo。
- (void)tg_beginLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_beginLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_endLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在第一次布局完成之后或者有横竖屏切换时进行处理的动作块。这个block不像tg_beginLayoutDo以及tg_endLayoutDo那样只会执行一次,而是会一直存在
/// 因此需要注意代码块里面的循环引用的问题。这个block调用的时机是第一次布局完成或者每次横竖屏切换时布局完成被调用。
/// 这个方法会在tg_endLayoutDo执行后调用。
/// <ul>
///   <li>
///     layout: 参数就是布局视图本身
///   </li>
///   <li>
///     isFirst: 表明当前是否是第一次布局时调用。
///   </li>
///   <li>
///     isPortrait: 表明当前是横屏还是竖屏。
///   </li>
/// </ul>
- (void)tg_rotationToDeviceOrientationDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, BOOL, BOOL))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_rotationToDeviceOrientationDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 不使用父布局视图提供的智能边界线功能。当布局视图的父布局视图设置了tg_intelligentBorderline时但是布局视图又想自己定义边界线时则将这个属性设置为true
@property (nonatomic) BOOL tg_notUseIntelligentBorderline SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_notUseIntelligentBorderline' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_setTarget:(id <NSObject> _Nullable)target action:(SEL _Nullable)action for:(UIControlEvents)controlEvents SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_setTarget(_:action:for:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时背景的高亮的颜色。只有设置了tg_setTarget方法后此属性才生效。
@property (nonatomic, strong) UIColor * _Null_unspecified tg_highlightedBackgroundColor SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundColor' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮不透明度。值的范围是[0,1]，默认是0表示完全不透明，为1表示完全透明。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic) CGFloat tg_highlightedOpacity SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedOpacity' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局的背景图片。这个属性的设置就是设置了布局的layer.contents的值，因此如果要实现背景图的局部拉伸请用layer.contentsXXX这些属性进行调整
@property (nonatomic, strong) UIImage * _Null_unspecified tg_backgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_backgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮背景图片。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic, strong) UIImage * _Null_unspecified tg_highlightedBackgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)safeAreaInsetsDidChange;
- (void)setNeedsLayout;
@property (nonatomic, readonly) CGSize intrinsicContentSize;
- (void)layoutSubviews;
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
- (CGSize)sizeThatFits:(CGSize)size SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, getter=isHidden) BOOL hidden;
- (void)awakeFromNib;
- (void)didAddSubview:(UIView * _Nonnull)subview;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (void)willMoveToSuperview:(UIView * _Nullable)newSuperview;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// 浮动布局是一种里面的子视图按照约定的方向浮动停靠，当浮动布局的剩余空间不足容纳子视图的尺寸时会自动寻找最佳的位置进行浮动停靠的布局视图。
/// *浮动布局的理念源于HTML/CSS中的浮动定位技术,因此浮动布局可以专门用来实现那些不规则布局或者图文环绕的布局。
/// *根据浮动的方向不同，浮动布局可以分为左右浮动布局和上下浮动布局。我们称左右浮动的浮动布局为垂直浮动布局，因为左右浮动时最终整个方向是从上到下的；称上下浮动的浮动布局为水平浮动布局，因为上下浮动时最终整个方向是从左到右的。
SWIFT_CLASS("_TtC10TangramKit13TGFloatLayout")
@interface TGFloatLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *不做布局边界尺寸的限制，子视图不会自动换行，因此当设置为true时，子视图需要设置tg_clearFloat来实现主动换行的处理。默认为false。
/// *当布局的orientation为.vert并且tg_width.equal(.wrap)时,这个属性设置为true才生效。
/// *当布局的orientation为.horz并且tg_height.equal(.wrap)时，这个属性设置为true才生效。
/// *当属性设置为true时，子视图不能将扩展属性tg_reverseFloat设置为true，否则将导致结果异常。
/// *这个属性设置为true时，在左右浮动布局中，子视图只能向左浮动，并且没有右边界的限制，因此如果子视图没有tg_clearFloat时则总是排列在前一个子视图的右边，并不会自动换行,因此为了让这个属性生效，布局视图必须要同时设置tg_width.equal(.wrap)。
/// *这个属性设置为true时，在上下浮动布局中，子视图只能向上浮动，并且没有下边界的限制，因此如果子视图没有设置tg_clearFloat时则总是排列在前一个子视图的下边，并不会自动换行，因此为了让这个属性生效，布局视图必须要同时设置tg_height.equal(.wrap).
@property (nonatomic) BOOL tg_noBoundaryLimit SWIFT_DEPRECATED_OBJC("Swift property 'TGFloatLayout.tg_noBoundaryLimit' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *流式布局是一种里面的子视图按照添加的顺序依次排列，当遇到某种约束限制后会另起一排再重新排列的多行多列展示的布局视图。这里的约束限制主要有数量约束限制和内容尺寸约束限制两种，排列的方向又分为垂直和水平方向，因此流式布局一共有垂直数量约束流式布局、垂直内容约束流式布局、水平数量约束流式布局、水平内容约束流式布局。流式布局主要应用于那些有规律排列的场景，在某种程度上可以作为UICollectionView的替代品。
/// 1.垂直数量约束流式布局
/// tg_orientation=.vert,tg_arrangedCount>0
/// 每排数量为3的垂直数量约束流式布局
/// =>
/// +——+—+—–+
/// |  A   | B |  C  |
/// +—+–+-+-+—–+
/// | D |  E |   F   |  |
/// +—+-+–+–+––+  v
/// |  G  |  H  | I  |
/// +—–+—–+––+
/// 2.垂直内容约束流式布局.
/// tg_orientation = .vert,tg_arrangedCount = 0
/// 垂直内容约束流式布局
/// =>
/// +—–+———–+
/// |  A  |     B     |
/// +—–+—–+—–+
/// |  C  |  D  |  E  |  |
/// +—–+—–+—–+  v
/// |        F        |
/// +—————–+
/// 3.水平数量约束流式布局。
/// tg_orientation = .horz,tg_arrangedCount > 0
/// 每排数量为3的水平数量约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | D  |     |
/// |     |––|  G  |
/// |—–|    |     |
/// |  |  B  | E  |—–|
/// V  |—–|    |     |
/// |     |––|  H  |
/// |  C  |    |—–|
/// |     | F  |  I  |
/// +—–+––+—–+
/// 4.水平内容约束流式布局
/// tg_orientation = .horz,arrangedCount = 0
/// 水平内容约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | C  |     |
/// |     |––|     |
/// |—–|    |     |
/// |  |     | D  |     |
/// V  |     |    |  F  |
/// |  B  |––|     |
/// |     |    |     |
/// |     | E  |     |
/// +—–+––+—–+
/// 流式布局中排的概念是一个通用的称呼，对于垂直方向的流式布局来说一排就是一行，垂直流式布局每排依次从上到下排列，每排内的子视图则是由左往右依次排列；对于水平方向的流式布局来说一排就是一列，水平流式布局每排依次从左到右排列，每排内的子视图则是由上往下依次排列
SWIFT_CLASS("_TtC10TangramKit12TGFlowLayout")
@interface TGFlowLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *指定方向上的子视图的数量，默认是0表示为内容约束流式布局，当数量不为0时则是数量约束流式布局。当值为0时则表示当子视图在方向上的尺寸超过布局视图时则会新起一排。而如果数量不为0时则：
/// 如果方向为.vert，则表示从左到右的数量，当子视图从左往右满足这个数量后新的子视图将会新起一排
/// 如果方向为.horz，则表示从上到下的数量，当子视图从上往下满足这个数量后新的子视图将会新起一排
@property (nonatomic) NSInteger tg_arrangedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_arrangedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *为流式布局提供分页展示的能力,默认是0表不支持分页展示，当设置为非0时则要求必须是tg_arrangedCount的整数倍数，表示每页的子视图的数量。而tg_arrangedCount则表示每排的子视图的数量。当启用tg_pagedCount时要求将流式布局加入到UIScrollView或者其派生类中才能生效。只有数量约束流式布局才支持分页展示的功能，tg_pagedCount和tg_height.isWrap以及tg_width.isWrap配合使用能实现不同的分页展示能力:
/// 1.垂直数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从左到右再从上到下排列，新页往下滚动继续排列)：
/// 1  2  3
/// 4  5  6
/// —––  ↓
/// 7  8  9
/// 10 11 12
/// 2.垂直数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从左到右再从上到下排列，新页往右滚动继续排列)
/// 1  2  3 | 7  8  9
/// 4  5  6 | 10 11 12
/// →
/// 1.水平数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从上到下再从左到右排列，新页往右滚动继续排列)
/// 1  3  5 | 7  9   11
/// 2  4  6 | 8  10  12
/// →
/// 2.水平数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从上到下再从左到右排列，新页往下滚动继续排列)
/// 1  3  5
/// 2  4  6
/// ——— ↓
/// 7  9  11
/// 8  10 12
@property (nonatomic) NSInteger tg_pagedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_pagedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *子视图自动排列,这个属性只有在内容填充约束流式布局下才有用,默认为false.当设置为YES时则根据子视图的内容自动填充，而不是根据加入的顺序来填充，以便保证不会出现多余空隙的情况。
/// *请在将所有子视图添加完毕并且初始布局完成后再设置这个属性，否则如果预先设置这个属性则在后续添加子视图时非常耗性能。
@property (nonatomic) BOOL tg_autoArrange SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_autoArrange' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *框架布局是一种里面的子视图停靠在父视图特定方位并且可以重叠的布局视图。框架布局里面的子视图的布局位置和添加的顺序无关，只跟父视图建立布局约束依赖关系。
/// *框架布局是一种简化的相对布局。也就是里面子视图的TGLayoutPos对象所设置的值都是距离父布局视图的边距值，里面的TGLayoutSize对象所设置的值都是相对于父视图的尺寸来处理的。
SWIFT_CLASS("_TtC10TangramKit13TGFrameLayout")
@interface TGFrameLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *线性布局是一种里面的子视图按添加的顺序从上到下或者从左到右依次排列的单行(单列)布局视图。线性布局里面的子视图是通过添加的顺序建立约束和依赖关系的。
/// *根据排列的方向我们把子视图从上到下依次排列的线性布局视图称为垂直线性布局视图，而把子视图从左到右依次排列的线性布局视图则称为水平线性布局。
/// 垂直线性布局
/// +—––+
/// |   A   |
/// +—––+
/// |   B   |
/// +—––+  ⥥
/// |   C   |
/// +—––+
/// |  …  |
/// +—––+
/// 水平线性布局
/// +—–+—–+—–+—–+
/// |  A  |  B  |  C  | … |
/// +—–+—–+—–+—–+
/// ⥤
SWIFT_CLASS("_TtC10TangramKit14TGLinearLayout")
@interface TGLinearLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// 设置水平线性布局里面的基线对齐基准视图，所有其他子视图的基线都以这个为准。
/// 这个属性要和tg_gravity属性设置为TGGravity.vert.baseline配合使用。并且要求这个属性所指定的视图，必须具有font属性。
/// 目前支持具有font属性的有UILabel，UITextField,UITextView, UIButton几个系统控件。
@property (nonatomic, strong) UIView * _Null_unspecified tg_baselineBaseView SWIFT_DEPRECATED_OBJC("Swift property 'TGLinearLayout.tg_baselineBaseView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *路径布局类。路径布局通过坐标轴的设置，曲线路径函数方程，子视图中心点之间的距离三个要素来确定其中子视图的位置。因此通过路径布局可以实现一些非常酷炫的布局效果。
SWIFT_CLASS("_TtC10TangramKit12TGPathLayout")
@interface TGPathLayout : TGBaseLayout
/// 设置和获取布局视图中的原点视图，默认是nil。如果设置了原点视图则总会将原点视图作为布局视图中的最后一个子视图。原点视图将会显示在路径的坐标原点中心上，因此原点布局是不会参与在路径中的布局的。因为中心原点视图是布局视图中的最后一个子视图，而TGPathLayout重写了addSubview方法，因此可以正常的使用这个方法来添加子视图。
@property (nonatomic, strong) UIView * _Nullable tg_originView SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_originView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回布局视图中所有在曲线路径中排列的子视图。如果设置了原点视图则返回subviews里面除最后一个子视图外的所有子视图，如果没有原点子视图则返回subviews
@property (nonatomic, readonly, copy) NSArray<UIView *> * _Nonnull tg_pathSubviews SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_pathSubviews' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置获取子视图距离的误差值。默认是0.5，误差越小则距离的精确值越大，误差最低值不能<=0。一般不需要调整这个值，只有那些要求精度非常高的场景才需要微调这个值,比如在一些曲线路径较短的情况下，通过调小这个值来子视图之间间距的精确计算。
@property (nonatomic) CGFloat tg_distanceError SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_distanceError' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_beginSubviewPathPointWithFull:(BOOL)full SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_beginSubviewPathPoint(full:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endSubviewPathPoint SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_endSubviewPathPoint()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建从某个子视图到另外一个子视图之间的路径点，返回NSValue数组，里面的值是CGPoint。
/// fromIndex指定开始的子视图的索引位置，toIndex指定结束的子视图的索引位置。如果有原点子视图时,这两个索引值不能算上原点子视图的索引值。
- (NSArray<NSValue *> * _Nullable)tg_getSubviewPathPointFromIndex:(NSInteger)fromIndex toIndex:(NSInteger)toIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_getSubviewPathPoint(fromIndex:toIndex:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建布局的曲线的路径。用户需要负责销毁返回的值。调用者可以用这个方法来获得曲线的路径，进行一些绘制的工作。
/// subviewCount:指定这个路径上子视图的数量的个数，如果设置为-1则是按照布局视图的子视图的数量来创建。需要注意的是如果布局视图的tg_spaceType为.flexed,.count的话则这个参数设置无效。
- (CGPathRef _Nonnull)tg_createPathWithSubviewCount:(NSInteger)subviewCount SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_createPath(subviewCount:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)addSubview:(UIView * _Nonnull)view;
- (void)sendSubviewToBack:(UIView * _Nonnull)view;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *相对布局是一种里面的子视图通过相互之间的约束和依赖来进行布局和定位的布局视图。
/// *相对布局里面的子视图的布局位置和添加的顺序无关，而是通过设置子视图的相对依赖关系来进行定位和布局的。
/// *相对布局提供和AutoLayout等价的功能。
SWIFT_CLASS("_TtC10TangramKit16TGRelativeLayout")
@interface TGRelativeLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *表格布局是一种里面的子视图可以像表格一样进行多行多列排列的布局视图。子视图添加到表格布局视图前必须先要建立并添加行子视图，然后再将列子视图添加到行子视图里面。
/// *表格里面的行子视图和列子视图的排列方向的概念是相对的，他根据表格布局方向的不同而不同。表格布局根据方向可分为垂直表格布局和水平表格布局。
/// *对于垂直表格布局来说，行子视图是从上到下依次排列的，而列子视图则是在行子视图里面从左到右依次排列。
/// *对于水平表格布局来说，行子视图是从左到右依次排列的，而列子视图则是在行子视图里面从上到下依次排列。
SWIFT_CLASS("_TtC10TangramKit13TGTableLayout")
@interface TGTableLayout : TGLinearLayout
/// 删除一行
- (void)tg_removeRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeRow(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两行的位置
- (void)tg_exchangeRow:(NSInteger)rowIndex1 with:(NSInteger)rowIndex2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeRow(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行对象
- (TGLinearLayout * _Nonnull)tg_rowViewAt:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_rowView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行的数量
@property (nonatomic, readonly) NSInteger tg_rowCount SWIFT_DEPRECATED_OBJC("Swift property 'TGTableLayout.tg_rowCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 添加一个新的列。再添加一个新的列前必须要先添加行，对于垂直表格来说每一列是从左到右排列的，而对于水平表格来说每一列是从上到下排列的。
/// @colView:  列视图
/// @rowIndex: 指定要添加列的行的索引
- (void)tg_addCol:(UIView * _Nonnull)colView inRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_addCol(_:inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在指定的indexPath下插入一个新的列 IndexPath(row:1, col:1)
- (void)tg_insertCol:(UIView * _Nonnull)colView inIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_insertCol(_:inIndexPath:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除一列
- (void)tg_removeCol:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeCol(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两个列视图，这两个列视图是可以跨行的
- (void)tg_exchangeCol:(NSIndexPath * _Nonnull)indexPath1 with:(NSIndexPath * _Nonnull)indexPath2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeCol(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回列视图
- (UIView * _Nonnull)tg_colViewAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回某行的列的数量
- (NSInteger)tg_colCountInRow:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colCount(inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGFloat tg_vspace;
@property (nonatomic) CGFloat tg_hspace;
/// *表格布局的addSubView被重新定义，是addCol:atRow的精简版本，表示插入当前行的最后一列
- (void)addSubview:(UIView * _Nonnull)view;
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
- (void)insertSubview:(UIView * _Nonnull)view belowSubview:(UIView * _Nonnull)siblingSubview;
- (void)insertSubview:(UIView * _Nonnull)view aboveSubview:(UIView * _Nonnull)siblingSubview;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end






@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 是否反方向浮动，默认是false表示正向浮动，正向浮动和反向浮动的意义根据所在的父浮动布局视图的方向的不同而不同：
/// 1.如果父视图是垂直浮动布局则默认正向浮动是向左浮动的，而反向浮动则是向右浮动。
/// 2.如果父视图是水平浮动布局则默认正向浮动是向上浮动的，而反向浮动则是向下浮动。
/// 下面是垂直浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F)：
/// |<–A– <—B—    -C->|
/// |<—–D–– -F-> –E–>|
/// 下面是水平浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F):
/// <hr/>
/// <h2>↑   ↑
/// |   |
/// A   |
/// |   D
/// |
/// ↑   |
/// B
/// |   F
/// ↓
/// |   |
/// C   E
/// ↓   ↓</h2>
@property (nonatomic) BOOL tg_reverseFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_reverseFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *清除浮动，默认是false。这个属性的意义也跟父浮动布局视图的方向相关。如果设置为了清除浮动属性则表示本视图不会在浮动方向上紧跟在前一个浮动视图的后面，而是会另外新起一行或者一列来重新排列。tg_reverseFloat和tg_clearFloat这两个属性的定义是完全参考CSS样式表中浮动布局中的float和clear这两个属性。
/// 垂直浮动布局下的浮动和清除浮动
/// |<–A– <—B— <-C–|
/// |<––D—            |
/// |<–E– <—F–       |
/// |<—–G––          |
/// |      —I—> –H–>|
/// |                -J-> |
/// A(正向浮动);B(正向浮动);C(正向浮动);D(正向浮动);E(正向浮动);F(正向浮动);G(正向浮动，清除浮动);H(反向浮动);I(反向浮动);J(反向浮动，清除浮动)
@property (nonatomic) BOOL tg_clearFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_clearFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end




@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置开始位置的快捷方法。
/// \param point 左上角原点的位置
///
- (void)tg_origin:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_origin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// \param point 右下角的结束位置
///
- (void)tg_end:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_end(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 同时设置tg_width和tg_height的简化方法。
/// \param size 宽度和高度值
///
- (void)tg_size:(CGSize)size SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_size(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 四周边距或者间距设置的简化方法
/// \param val 距离父视图四周的边距或者兄弟视图四周间距的值
///
- (void)tg_margin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_margin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 水平边距或者间距设置的简化方法
/// \param val 距离父视图左右水平边距或者兄弟视图左右间距的值
///
- (void)tg_horzMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_horzMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 垂直边距或者间距设置的简化方法
/// \param val 距离父视图上下垂直边距或者兄弟视图上下间距的值
///
- (void)tg_vertMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_vertMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图的在父布局视图调用完评估尺寸的方法后，可以通过这个方法来获取评估的CGRect值。评估的CGRect值是在布局前评估计算的值，而frame则是视图真正完成布局后的真实的CGRect值。在调用这个方法前请先调用父布局视图的tg_sizeThatFits方法进行布局视图的尺寸评估，否则此方法返回的值未可知。这个方法主要用于在视图布局前而想得到其在父布局视图中的位置和尺寸的场景。
@property (nonatomic, readonly) CGRect tg_estimatedFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_estimatedFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图在父布局视图中布局完成后也就是视图的frame更新完成后执行的block，执行完block后会被重置为nil。通过在tg_layoutCompletedDo中我们可以得到这个视图真实的frame值,当然您也可以在里面进行其他业务逻辑的操作和属性的获取和更新。block方法中layout参数就是父布局视图，而v就是视图本身，block中这两个参数目的是为了防止循环引用的问题。
/// \param action 布局完成执行的action
///
- (void)tg_layoutCompletedDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, UIView * _Nonnull))action SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_layoutCompletedDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end


@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置视图不受布局父视图的布局约束控制和不再参与视图的布局，所有设置的其他扩展属性都将失效而必须用frame来设置视图的位置和尺寸，默认值是false。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_useFrame = true
/// 那么在布局完成后：
/// A.frame == {0, 0, 100, 100}
/// B.frame == {20,20,200,100}   //可以看出B并没有受到约束的限制，结果就是B设置的frame值。
/// C.frame == {0, 100,100,200}  //因为B不再参与布局了，所以C就往上移动了，由原来的150变为了100.
/// tg_useFrame的应用场景是某个视图虽然是布局视图的子视图但不想受到父布局视图的约束，而是可以通过frame进行自由位置和尺寸调整的场景。
@property (nonatomic) BOOL tg_useFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_useFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置视图在进行布局时只会参与布局但不会真实的调整位置和尺寸，默认值是false。当设置为YES时会在布局时保留出视图的布局位置和布局尺寸的空间，但不会更新视图的位置和尺寸，也就是说只会占位但不会更新。因此你可以通过frame值来进行位置和尺寸的任意设置，而不会受到你的布局视图的影响。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_noLayout = true
/// 那么在布局完成后：
/// A.frame == {0,0,100,100}
/// B.frame == {20,20,200,100}  //可以看出虽然B参与了布局，但是并没有更新B的frame值，而是保持为通过frame设置的原始值。
/// C.frame == {0,150,100,200}  //因为B参与了布局，占用了50的高度，所以这里C的位置还是150，而不是100.
/// tg_useFrame和tg_noLayout的区别是：
/// <ol>
///   <li>
///     前者不会参与布局而必须要通过frame值进行设置，而后者则会参与布局但是不会将布局的结果更新到frame中。
///   </li>
///   <li>
///     当前者设置为true时后者的设置将无效，而后者的设置并不会影响前者的设置。
///   </li>
/// </ol>
/// tg_noLayout的应用场景是那些想在运行时动态调整某个视图的位置和尺寸，但是又不想破坏布局视图中其他子视图的布局结构的场景，也就是调整了视图的位置和尺寸，但是不会调整其他的兄弟子视图的位置和尺寸。
@property (nonatomic) BOOL tg_noLayout SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_noLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__i386__) && __i386__
// Generated by Apple Swift version 5.2.2 (swiftlang-1103.0.32.6 clang-1103.0.32.51)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="TangramKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIWindow;
@protocol NSObject;
@class UIColor;
@class UIImage;
@class UITraitCollection;
@class UITouch;
@class UIEvent;
@class NSCoder;

/// 布局视图基类，基类不支持实例化对象。在编程时我们经常会用到一些视图，这种视图只是负责将里面的子视图按照某种规则进行排列和布局，而别无其他的作用。因此我们称这种视图为容器视图或者称为布局视图。
/// 布局视图通过重载layoutSubviews方法来完成子视图的布局和排列的工作。对于每个加入到布局视图中的子视图，都会在加入时通过KVO机制监控子视图的center和bounds以及frame值的变化，每当子视图的这些属性一变化时就又会重新引发布局视图的布局动作。同时对每个视图的布局扩展属性的设置以及对布局视图的布局属性的设置都会引发布局视图的布局动作。布局视图在添加到非布局父视图时也会通过KVO机制来监控非布局父视图的frame值和bounds值，这样每当非布局父视图的尺寸变更时也会引发布局视图的布局动作。前面说的引起变动的方法就是会在KVO处理逻辑以及布局扩展属性和布局属性设置完毕后通过调用setNeedLayout来实现的，当布局视图收到setNeedLayout的请求后，会在下一个runloop中对布局视图进行重新布局而这就是通过调用layoutSubviews方法来实现的。布局视图基类只提供了更新所有子视图的位置和尺寸以及一些基础的设置，而至于如何排列和布局这些子视图则要根据应用的场景和需求来确定，因此布局基类视图提供了一个：
/// internal func tgCalcLayoutRect(_ size:CGSize, isEstimate:Bool, hasSubLayout:inout Bool!, sbs:[UIView]!, type:TGSizeClassType) ->CGSize
/// 的方法，要求派生类去重载这个方法，这样不同的派生类就可以实现不同的应用场景，这就是布局视图的核心实现机制。
/// TangramKit布局库根据实际中常见的场景实现了7种不同的布局视图派生类他们分别是：线性布局、表格布局、相对布局、框架布局、流式布局、浮动布局、路径布局。
SWIFT_CLASS("_TtC10TangramKit12TGBaseLayout")
@interface TGBaseLayout : UIView
/// 用于实现对阿拉伯国家的布局适配。对于非阿拉伯国家来说，界面布局都是默认从左到右排列。而对于阿拉伯国家来说界面布局则默认是从右往左排列。默认这个属性是NO，您可以将这个属性设置为YES，这样布局里面的所有视图都将从右到左进行排列布局。如果您需要考虑国际化布局的问题，那么您应该用tg_leading来表示头部的位置，而用tg_trailing来表示尾部的位置，这样当布局方向是LTR时那么tg_leading就表示的是左边而tg_trailing则表示的是右边；而当布局方向是RTL时那么tg_leading表示的是右边而tg_trailing则表示的是左边。如果您的界面布局不会考虑到国际化以及不需要考虑RTL时那么您可以用tg_left和tg_right来表示左右而不需要用tg_leading和tg_trailing。
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL tg_isRTL SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");)
+ (BOOL)tg_isRTL SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)setTg_isRTL:(BOOL)newValue SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)tg_updateRTL:(BOOL)isRTL inWindow:(UIWindow * _Nonnull)window SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_updateRTL(_:inWindow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图四周的内边距值。所谓内边距是指布局视图内的所有子视图离布局视图四周的边距。通过为布局视图设置内边距可以减少为所有子视图设置外边距的工作，而外边距则是指视图离父视图四周的距离。
@property (nonatomic) UIEdgeInsets tg_padding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_padding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 顶部内边距
@property (nonatomic) CGFloat tg_topPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_topPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 头部内边距，用来设置子视图离自身头部的边距值。对于LTR方向的布局来说就是指的左边内边距，而对于RTL方向的布局来说就是指的右边内边距。
@property (nonatomic) CGFloat tg_leadingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leadingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 底部内边距
@property (nonatomic) CGFloat tg_bottomPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_bottomPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 尾部内边距，用来设置子视图离自身尾部的边距值。对于LTR方向的布局来说就是指的右边内边距，而对于RTL方向的布局来说就是指的左边内边距。
@property (nonatomic) CGFloat tg_trailingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_trailingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 左边内边距。
@property (nonatomic) CGFloat tg_leftPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leftPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 右边内边距
@property (nonatomic) CGFloat tg_rightPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_rightPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置当布局的尺寸由子视图决定并且在没有子视图的情况下tg_padding的设置值是否会加入到布局的尺寸值里面。默认是true，表示当布局视图没有子视图时tg_padding值也会加入到尺寸里面。
/// 举例来说假设某个布局视图的高度是.wrap,并且设置了tg_topPadding为10，tg_bottomPadding为20。那么默认情况下当没有任何子视图时布局视图的高度是30；而当我们将这个属性设置为false时，那么在没有任何子视图时布局视图的高度就是0，也就是说tg_padding不会参与高度的计算了。
@property (nonatomic) BOOL tg_zeroPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_zeroPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 指定padding内边距的缩进是在SafeArea基础之上进行的。默认是.all表示四周都会缩进SafeArea所指定的区域。你也可以设置只缩进某一个或则几个方向，或者不缩进任何一个方向。这个属性是为了支持iPoneX而设置的。为了支持iPhoneX的全屏幕适配。我们只需要对根布局视图设置这个扩展属性，默认情况下是不需要进行特殊设置的，TangramKit自动会对iPhoneX进行适配。我们知道iOS11中引入了安全区域的概念，TangramKit中的根布局视图会自动将安全区域叠加到设置的padding中去。默认情况下左右的安全区域都会叠加到padding中去，因此您可以根据特殊情况来设置只需要叠加哪一个方向的安全区域。
@property (nonatomic) UIRectEdge tg_insetsPaddingFromSafeArea SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetsPaddingFromSafeArea' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *当tg_insetsPaddingFromSafeArea同时设置有左右方向同时缩进并且在横屏时是否只缩进有刘海方向的内边距。默认是false，表示两边都会缩进。如果你想让没有刘海的那一边延伸到屏幕的安全区外，请将这个属性设置为true。iPhoneX设备中具有一个尺寸为44的刘海区域。当您横屏时为了对齐，左右两边的安全缩进区域都是44。但是有些时候我们希望没有刘海的那一边不需要缩进对齐而是延伸到安全区域以外。这时候您可以通过给根布局视图设置这个属性来达到效果。注意这个属性只有tg_insetsPaddingFromSafeArea设置了左右都缩进时才有效。
@property (nonatomic) BOOL tg_insetLandscapeFringePadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetLandscapeFringePadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的间距，所谓间距就是子视图之间的间隔距离。
@property (nonatomic) CGFloat tg_space SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_space' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的上下垂直间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_vspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_vspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的左右水平间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_hspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_hspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 布局里面的所有子视图按添加的顺序逆序进行布局。默认是false，表示按子视图添加的顺序排列。比如一个垂直线性布局依次添加A,B,C三个子视图，那么在布局时则A,B,C从上到下依次排列。当这个属性设置为YES时，则布局时C,B,A依次从上到下排列。
@property (nonatomic) BOOL tg_reverseLayout SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_reverseLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGAffineTransform tg_layoutTransform SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_layoutTransform' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在布局视图进行布局时是否调用基类的layoutSubviews方法，默认设置为false。
@property (nonatomic) BOOL tg_priorAutoresizingMask SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_priorAutoresizingMask' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回当前布局视图是否正在执行布局。
@property (nonatomic, readonly) BOOL tg_isLayouting SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isLayouting' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置是否选中状态。您可以用这个状态来记录布局的扩展属性。
@property (nonatomic) BOOL isSelected SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.isSelected' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除所有子视图
- (void)tg_removeAllSubviews SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_removeAllSubviews()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 执行布局动画。在布局视图的某个子视图设置完布局属性后，调用布局的这个方法可以让布局里面的子视图在布局时实现动画效果。
/// \param duration 动画时长
///
- (void)tg_layoutAnimationWithDuration:(NSTimeInterval)duration SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_layoutAnimationWithDuration(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 是否缓存经过tg_sizeThatFits方法评估后的所有子视图的位置和尺寸一次!，默认设置为false不缓存。当我们用tg_sizeThatFits方法评估布局视图的尺寸后，所有子视图都会生成评估的位置和尺寸，因为此时并没有执行布局所以子视图并没有真实的更新frame值。而当布局视图要进行真实布局时又会重新计算所有子视图的位置和尺寸，因此为了优化性能当我们对布局进行评估后在下次真实布局时我们可以不再重新计算子视图的位置和尺寸而是用前面评估的值来设置位置和尺寸。这个属性设置为true时则每次评估后到下一次布局时不会再重新计算子视图的布局了，而是用评估值来布局子视图的位置和尺寸。而当这个属性设置为false时则每次布局都会重新计算子视图的位置和布局。
/// 这个属性一般用在那些动态高度UITableviewCell中进行配合使用，我们一般将布局视图作为UITableviewCell的contentView的子视图:
/// let rootLayout= TGXXXLayout()
/// rootLayout.tg_cacheEstimatedRect = true   //设置缓存评估的rect,如果您的cell是高度自适应的话，强烈建立打开这个属性，这会大大的增强您的tableview的性能！！
/// rootLayout.tg_width.equal(.fill)           //宽度和父视图相等
/// rootLayout.tg_height.equal(.wrap)    //高度动态包裹。
/// self.contentView.addSubview(rootLayout)
/// self.rootLayout = rootLayout;
/// //在rootLayout添加子视图。。。
/// <hr/>
/// 然后我们在heightForRowAtIndexPath中按如下格式进行高度的评估的计算。
/// override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
/// let cell = self.tableView(tableView,cellForRowAt:indexPath) as! UIXXXTableViewCell
/// let size = cell.rootLayout.tg_sizeThatFits(CGSize(width:tableView.frame.width, height:0))
/// return size.height;
/// }
/// 这个属性有可能会造成动态高度计算不正确，请只在UITableviewCell的高度为自适应时使用，其他地方不建议设置这个属性！！
@property (nonatomic) BOOL tg_cacheEstimatedRect SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_cacheEstimatedRect' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 评估计算一个未加入到布局视图中的子视图subview在加入后的frame值。在实践中我们希望得到某个未加入的子视图在添加到布局视图后的应该具有的frame值，这时候就可以用这个方法来获取。比如我们希望把一个子视图从一个布局视图里面移到另外一个布局视图的末尾时希望能够提供动画效果,这时候就可以通过这个方法来得到加入后的子视图的位置和尺寸。
/// 这个方法只有针对那些通过添加顺序进行约束的布局视图才有意义，相对布局和框架布局则没有意义。
/// 使用示例：假设存在两个布局视图L1,L2他们的父视图是S，现在要实现将L1中的任意一个子视图A移动到L2的末尾中去，而且要带动画效果，那么代码如下：
/// //得到A在S中的frame，这里需要进行坐标转换为S在中的frame
/// let rectOld = L1.convert(A.frame, to: S)
/// //得到将A加入到L2后的评估的frame值，注意这时候A还没有加入到L2。
/// var rectNew = L2.tg_estimatedFrame(of: A)
/// rectNew = L2.convert(rectNew, to: S) //将新位置的评估的frame值，这里需要进行坐标转换为S在中的frame。
/// //动画的过程是先将A作为S的子视图进行位置的调整后再加入到L2中去
/// A.removeFromSuperview()
/// A.frame = rectOld
/// A.tg_useFrame = true  //设置为true表示A不再受到布局视图的约束，而是可以自由设置frame值。
/// S.addSubview(sender)
/// UIView.animate(withDuration: 0.3, animations: {
/// A.frame = rectNew
/// }) { _ in
/// //动画结束后再将A移植到L2中。
/// A.removeFromSuperview()
/// A.tg_useFrame = false  //还原tg_useFrame，因为加入到L2后将受到布局视图的约束。
/// L2.addSubview(A)
/// }
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     subview: 一个未加入布局视图的子视图，如果子视图已经加入则直接返回子视图的frame值。
///   </li>
///   <li>
///     size:指定布局视图期望的宽度或者高度，一般请将这个值设置为.zero。 具体请参考tg_sizeThatFits方法中的size的说明。
///   </li>
/// </ul>
///
/// returns:
/// 子视图在布局视图最后一个位置(假如加入后)的frame值。
- (CGRect)tg_estimatedFrameOf:(UIView * _Nonnull)subview inLayoutSize:(CGSize)size SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_estimatedFrame(of:inLayoutSize:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在布局开始之前和布局完成之后的处理块。系统会在每次布局完成前后分别执行对应的处理块后将处理块清空为nil。您也可以在tg_endLayoutDo块内取到所有子视图真实布局后的frame值。系统会在调用layoutSubviews方法前执行tg_beginLayoutDo，而在layoutSubviews方法执行后执行tg_endLayoutDo。
- (void)tg_beginLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_beginLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_endLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在第一次布局完成之后或者有横竖屏切换时进行处理的动作块。这个block不像tg_beginLayoutDo以及tg_endLayoutDo那样只会执行一次,而是会一直存在
/// 因此需要注意代码块里面的循环引用的问题。这个block调用的时机是第一次布局完成或者每次横竖屏切换时布局完成被调用。
/// 这个方法会在tg_endLayoutDo执行后调用。
/// <ul>
///   <li>
///     layout: 参数就是布局视图本身
///   </li>
///   <li>
///     isFirst: 表明当前是否是第一次布局时调用。
///   </li>
///   <li>
///     isPortrait: 表明当前是横屏还是竖屏。
///   </li>
/// </ul>
- (void)tg_rotationToDeviceOrientationDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, BOOL, BOOL))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_rotationToDeviceOrientationDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 不使用父布局视图提供的智能边界线功能。当布局视图的父布局视图设置了tg_intelligentBorderline时但是布局视图又想自己定义边界线时则将这个属性设置为true
@property (nonatomic) BOOL tg_notUseIntelligentBorderline SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_notUseIntelligentBorderline' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_setTarget:(id <NSObject> _Nullable)target action:(SEL _Nullable)action for:(UIControlEvents)controlEvents SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_setTarget(_:action:for:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时背景的高亮的颜色。只有设置了tg_setTarget方法后此属性才生效。
@property (nonatomic, strong) UIColor * _Null_unspecified tg_highlightedBackgroundColor SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundColor' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮不透明度。值的范围是[0,1]，默认是0表示完全不透明，为1表示完全透明。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic) CGFloat tg_highlightedOpacity SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedOpacity' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局的背景图片。这个属性的设置就是设置了布局的layer.contents的值，因此如果要实现背景图的局部拉伸请用layer.contentsXXX这些属性进行调整
@property (nonatomic, strong) UIImage * _Null_unspecified tg_backgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_backgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮背景图片。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic, strong) UIImage * _Null_unspecified tg_highlightedBackgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)safeAreaInsetsDidChange;
- (void)setNeedsLayout;
@property (nonatomic, readonly) CGSize intrinsicContentSize;
- (void)layoutSubviews;
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
- (CGSize)sizeThatFits:(CGSize)size SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, getter=isHidden) BOOL hidden;
- (void)awakeFromNib;
- (void)didAddSubview:(UIView * _Nonnull)subview;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (void)willMoveToSuperview:(UIView * _Nullable)newSuperview;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// 浮动布局是一种里面的子视图按照约定的方向浮动停靠，当浮动布局的剩余空间不足容纳子视图的尺寸时会自动寻找最佳的位置进行浮动停靠的布局视图。
/// *浮动布局的理念源于HTML/CSS中的浮动定位技术,因此浮动布局可以专门用来实现那些不规则布局或者图文环绕的布局。
/// *根据浮动的方向不同，浮动布局可以分为左右浮动布局和上下浮动布局。我们称左右浮动的浮动布局为垂直浮动布局，因为左右浮动时最终整个方向是从上到下的；称上下浮动的浮动布局为水平浮动布局，因为上下浮动时最终整个方向是从左到右的。
SWIFT_CLASS("_TtC10TangramKit13TGFloatLayout")
@interface TGFloatLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *不做布局边界尺寸的限制，子视图不会自动换行，因此当设置为true时，子视图需要设置tg_clearFloat来实现主动换行的处理。默认为false。
/// *当布局的orientation为.vert并且tg_width.equal(.wrap)时,这个属性设置为true才生效。
/// *当布局的orientation为.horz并且tg_height.equal(.wrap)时，这个属性设置为true才生效。
/// *当属性设置为true时，子视图不能将扩展属性tg_reverseFloat设置为true，否则将导致结果异常。
/// *这个属性设置为true时，在左右浮动布局中，子视图只能向左浮动，并且没有右边界的限制，因此如果子视图没有tg_clearFloat时则总是排列在前一个子视图的右边，并不会自动换行,因此为了让这个属性生效，布局视图必须要同时设置tg_width.equal(.wrap)。
/// *这个属性设置为true时，在上下浮动布局中，子视图只能向上浮动，并且没有下边界的限制，因此如果子视图没有设置tg_clearFloat时则总是排列在前一个子视图的下边，并不会自动换行，因此为了让这个属性生效，布局视图必须要同时设置tg_height.equal(.wrap).
@property (nonatomic) BOOL tg_noBoundaryLimit SWIFT_DEPRECATED_OBJC("Swift property 'TGFloatLayout.tg_noBoundaryLimit' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *流式布局是一种里面的子视图按照添加的顺序依次排列，当遇到某种约束限制后会另起一排再重新排列的多行多列展示的布局视图。这里的约束限制主要有数量约束限制和内容尺寸约束限制两种，排列的方向又分为垂直和水平方向，因此流式布局一共有垂直数量约束流式布局、垂直内容约束流式布局、水平数量约束流式布局、水平内容约束流式布局。流式布局主要应用于那些有规律排列的场景，在某种程度上可以作为UICollectionView的替代品。
/// 1.垂直数量约束流式布局
/// tg_orientation=.vert,tg_arrangedCount>0
/// 每排数量为3的垂直数量约束流式布局
/// =>
/// +——+—+—–+
/// |  A   | B |  C  |
/// +—+–+-+-+—–+
/// | D |  E |   F   |  |
/// +—+-+–+–+––+  v
/// |  G  |  H  | I  |
/// +—–+—–+––+
/// 2.垂直内容约束流式布局.
/// tg_orientation = .vert,tg_arrangedCount = 0
/// 垂直内容约束流式布局
/// =>
/// +—–+———–+
/// |  A  |     B     |
/// +—–+—–+—–+
/// |  C  |  D  |  E  |  |
/// +—–+—–+—–+  v
/// |        F        |
/// +—————–+
/// 3.水平数量约束流式布局。
/// tg_orientation = .horz,tg_arrangedCount > 0
/// 每排数量为3的水平数量约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | D  |     |
/// |     |––|  G  |
/// |—–|    |     |
/// |  |  B  | E  |—–|
/// V  |—–|    |     |
/// |     |––|  H  |
/// |  C  |    |—–|
/// |     | F  |  I  |
/// +—–+––+—–+
/// 4.水平内容约束流式布局
/// tg_orientation = .horz,arrangedCount = 0
/// 水平内容约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | C  |     |
/// |     |––|     |
/// |—–|    |     |
/// |  |     | D  |     |
/// V  |     |    |  F  |
/// |  B  |––|     |
/// |     |    |     |
/// |     | E  |     |
/// +—–+––+—–+
/// 流式布局中排的概念是一个通用的称呼，对于垂直方向的流式布局来说一排就是一行，垂直流式布局每排依次从上到下排列，每排内的子视图则是由左往右依次排列；对于水平方向的流式布局来说一排就是一列，水平流式布局每排依次从左到右排列，每排内的子视图则是由上往下依次排列
SWIFT_CLASS("_TtC10TangramKit12TGFlowLayout")
@interface TGFlowLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *指定方向上的子视图的数量，默认是0表示为内容约束流式布局，当数量不为0时则是数量约束流式布局。当值为0时则表示当子视图在方向上的尺寸超过布局视图时则会新起一排。而如果数量不为0时则：
/// 如果方向为.vert，则表示从左到右的数量，当子视图从左往右满足这个数量后新的子视图将会新起一排
/// 如果方向为.horz，则表示从上到下的数量，当子视图从上往下满足这个数量后新的子视图将会新起一排
@property (nonatomic) NSInteger tg_arrangedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_arrangedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *为流式布局提供分页展示的能力,默认是0表不支持分页展示，当设置为非0时则要求必须是tg_arrangedCount的整数倍数，表示每页的子视图的数量。而tg_arrangedCount则表示每排的子视图的数量。当启用tg_pagedCount时要求将流式布局加入到UIScrollView或者其派生类中才能生效。只有数量约束流式布局才支持分页展示的功能，tg_pagedCount和tg_height.isWrap以及tg_width.isWrap配合使用能实现不同的分页展示能力:
/// 1.垂直数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从左到右再从上到下排列，新页往下滚动继续排列)：
/// 1  2  3
/// 4  5  6
/// —––  ↓
/// 7  8  9
/// 10 11 12
/// 2.垂直数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从左到右再从上到下排列，新页往右滚动继续排列)
/// 1  2  3 | 7  8  9
/// 4  5  6 | 10 11 12
/// →
/// 1.水平数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从上到下再从左到右排列，新页往右滚动继续排列)
/// 1  3  5 | 7  9   11
/// 2  4  6 | 8  10  12
/// →
/// 2.水平数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从上到下再从左到右排列，新页往下滚动继续排列)
/// 1  3  5
/// 2  4  6
/// ——— ↓
/// 7  9  11
/// 8  10 12
@property (nonatomic) NSInteger tg_pagedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_pagedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *子视图自动排列,这个属性只有在内容填充约束流式布局下才有用,默认为false.当设置为YES时则根据子视图的内容自动填充，而不是根据加入的顺序来填充，以便保证不会出现多余空隙的情况。
/// *请在将所有子视图添加完毕并且初始布局完成后再设置这个属性，否则如果预先设置这个属性则在后续添加子视图时非常耗性能。
@property (nonatomic) BOOL tg_autoArrange SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_autoArrange' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *框架布局是一种里面的子视图停靠在父视图特定方位并且可以重叠的布局视图。框架布局里面的子视图的布局位置和添加的顺序无关，只跟父视图建立布局约束依赖关系。
/// *框架布局是一种简化的相对布局。也就是里面子视图的TGLayoutPos对象所设置的值都是距离父布局视图的边距值，里面的TGLayoutSize对象所设置的值都是相对于父视图的尺寸来处理的。
SWIFT_CLASS("_TtC10TangramKit13TGFrameLayout")
@interface TGFrameLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *线性布局是一种里面的子视图按添加的顺序从上到下或者从左到右依次排列的单行(单列)布局视图。线性布局里面的子视图是通过添加的顺序建立约束和依赖关系的。
/// *根据排列的方向我们把子视图从上到下依次排列的线性布局视图称为垂直线性布局视图，而把子视图从左到右依次排列的线性布局视图则称为水平线性布局。
/// 垂直线性布局
/// +—––+
/// |   A   |
/// +—––+
/// |   B   |
/// +—––+  ⥥
/// |   C   |
/// +—––+
/// |  …  |
/// +—––+
/// 水平线性布局
/// +—–+—–+—–+—–+
/// |  A  |  B  |  C  | … |
/// +—–+—–+—–+—–+
/// ⥤
SWIFT_CLASS("_TtC10TangramKit14TGLinearLayout")
@interface TGLinearLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// 设置水平线性布局里面的基线对齐基准视图，所有其他子视图的基线都以这个为准。
/// 这个属性要和tg_gravity属性设置为TGGravity.vert.baseline配合使用。并且要求这个属性所指定的视图，必须具有font属性。
/// 目前支持具有font属性的有UILabel，UITextField,UITextView, UIButton几个系统控件。
@property (nonatomic, strong) UIView * _Null_unspecified tg_baselineBaseView SWIFT_DEPRECATED_OBJC("Swift property 'TGLinearLayout.tg_baselineBaseView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *路径布局类。路径布局通过坐标轴的设置，曲线路径函数方程，子视图中心点之间的距离三个要素来确定其中子视图的位置。因此通过路径布局可以实现一些非常酷炫的布局效果。
SWIFT_CLASS("_TtC10TangramKit12TGPathLayout")
@interface TGPathLayout : TGBaseLayout
/// 设置和获取布局视图中的原点视图，默认是nil。如果设置了原点视图则总会将原点视图作为布局视图中的最后一个子视图。原点视图将会显示在路径的坐标原点中心上，因此原点布局是不会参与在路径中的布局的。因为中心原点视图是布局视图中的最后一个子视图，而TGPathLayout重写了addSubview方法，因此可以正常的使用这个方法来添加子视图。
@property (nonatomic, strong) UIView * _Nullable tg_originView SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_originView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回布局视图中所有在曲线路径中排列的子视图。如果设置了原点视图则返回subviews里面除最后一个子视图外的所有子视图，如果没有原点子视图则返回subviews
@property (nonatomic, readonly, copy) NSArray<UIView *> * _Nonnull tg_pathSubviews SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_pathSubviews' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置获取子视图距离的误差值。默认是0.5，误差越小则距离的精确值越大，误差最低值不能<=0。一般不需要调整这个值，只有那些要求精度非常高的场景才需要微调这个值,比如在一些曲线路径较短的情况下，通过调小这个值来子视图之间间距的精确计算。
@property (nonatomic) CGFloat tg_distanceError SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_distanceError' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_beginSubviewPathPointWithFull:(BOOL)full SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_beginSubviewPathPoint(full:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endSubviewPathPoint SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_endSubviewPathPoint()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建从某个子视图到另外一个子视图之间的路径点，返回NSValue数组，里面的值是CGPoint。
/// fromIndex指定开始的子视图的索引位置，toIndex指定结束的子视图的索引位置。如果有原点子视图时,这两个索引值不能算上原点子视图的索引值。
- (NSArray<NSValue *> * _Nullable)tg_getSubviewPathPointFromIndex:(NSInteger)fromIndex toIndex:(NSInteger)toIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_getSubviewPathPoint(fromIndex:toIndex:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建布局的曲线的路径。用户需要负责销毁返回的值。调用者可以用这个方法来获得曲线的路径，进行一些绘制的工作。
/// subviewCount:指定这个路径上子视图的数量的个数，如果设置为-1则是按照布局视图的子视图的数量来创建。需要注意的是如果布局视图的tg_spaceType为.flexed,.count的话则这个参数设置无效。
- (CGPathRef _Nonnull)tg_createPathWithSubviewCount:(NSInteger)subviewCount SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_createPath(subviewCount:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)addSubview:(UIView * _Nonnull)view;
- (void)sendSubviewToBack:(UIView * _Nonnull)view;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *相对布局是一种里面的子视图通过相互之间的约束和依赖来进行布局和定位的布局视图。
/// *相对布局里面的子视图的布局位置和添加的顺序无关，而是通过设置子视图的相对依赖关系来进行定位和布局的。
/// *相对布局提供和AutoLayout等价的功能。
SWIFT_CLASS("_TtC10TangramKit16TGRelativeLayout")
@interface TGRelativeLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *表格布局是一种里面的子视图可以像表格一样进行多行多列排列的布局视图。子视图添加到表格布局视图前必须先要建立并添加行子视图，然后再将列子视图添加到行子视图里面。
/// *表格里面的行子视图和列子视图的排列方向的概念是相对的，他根据表格布局方向的不同而不同。表格布局根据方向可分为垂直表格布局和水平表格布局。
/// *对于垂直表格布局来说，行子视图是从上到下依次排列的，而列子视图则是在行子视图里面从左到右依次排列。
/// *对于水平表格布局来说，行子视图是从左到右依次排列的，而列子视图则是在行子视图里面从上到下依次排列。
SWIFT_CLASS("_TtC10TangramKit13TGTableLayout")
@interface TGTableLayout : TGLinearLayout
/// 删除一行
- (void)tg_removeRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeRow(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两行的位置
- (void)tg_exchangeRow:(NSInteger)rowIndex1 with:(NSInteger)rowIndex2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeRow(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行对象
- (TGLinearLayout * _Nonnull)tg_rowViewAt:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_rowView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行的数量
@property (nonatomic, readonly) NSInteger tg_rowCount SWIFT_DEPRECATED_OBJC("Swift property 'TGTableLayout.tg_rowCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 添加一个新的列。再添加一个新的列前必须要先添加行，对于垂直表格来说每一列是从左到右排列的，而对于水平表格来说每一列是从上到下排列的。
/// @colView:  列视图
/// @rowIndex: 指定要添加列的行的索引
- (void)tg_addCol:(UIView * _Nonnull)colView inRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_addCol(_:inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在指定的indexPath下插入一个新的列 IndexPath(row:1, col:1)
- (void)tg_insertCol:(UIView * _Nonnull)colView inIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_insertCol(_:inIndexPath:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除一列
- (void)tg_removeCol:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeCol(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两个列视图，这两个列视图是可以跨行的
- (void)tg_exchangeCol:(NSIndexPath * _Nonnull)indexPath1 with:(NSIndexPath * _Nonnull)indexPath2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeCol(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回列视图
- (UIView * _Nonnull)tg_colViewAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回某行的列的数量
- (NSInteger)tg_colCountInRow:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colCount(inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGFloat tg_vspace;
@property (nonatomic) CGFloat tg_hspace;
/// *表格布局的addSubView被重新定义，是addCol:atRow的精简版本，表示插入当前行的最后一列
- (void)addSubview:(UIView * _Nonnull)view;
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
- (void)insertSubview:(UIView * _Nonnull)view belowSubview:(UIView * _Nonnull)siblingSubview;
- (void)insertSubview:(UIView * _Nonnull)view aboveSubview:(UIView * _Nonnull)siblingSubview;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end






@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 是否反方向浮动，默认是false表示正向浮动，正向浮动和反向浮动的意义根据所在的父浮动布局视图的方向的不同而不同：
/// 1.如果父视图是垂直浮动布局则默认正向浮动是向左浮动的，而反向浮动则是向右浮动。
/// 2.如果父视图是水平浮动布局则默认正向浮动是向上浮动的，而反向浮动则是向下浮动。
/// 下面是垂直浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F)：
/// |<–A– <—B—    -C->|
/// |<—–D–– -F-> –E–>|
/// 下面是水平浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F):
/// <hr/>
/// <h2>↑   ↑
/// |   |
/// A   |
/// |   D
/// |
/// ↑   |
/// B
/// |   F
/// ↓
/// |   |
/// C   E
/// ↓   ↓</h2>
@property (nonatomic) BOOL tg_reverseFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_reverseFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *清除浮动，默认是false。这个属性的意义也跟父浮动布局视图的方向相关。如果设置为了清除浮动属性则表示本视图不会在浮动方向上紧跟在前一个浮动视图的后面，而是会另外新起一行或者一列来重新排列。tg_reverseFloat和tg_clearFloat这两个属性的定义是完全参考CSS样式表中浮动布局中的float和clear这两个属性。
/// 垂直浮动布局下的浮动和清除浮动
/// |<–A– <—B— <-C–|
/// |<––D—            |
/// |<–E– <—F–       |
/// |<—–G––          |
/// |      —I—> –H–>|
/// |                -J-> |
/// A(正向浮动);B(正向浮动);C(正向浮动);D(正向浮动);E(正向浮动);F(正向浮动);G(正向浮动，清除浮动);H(反向浮动);I(反向浮动);J(反向浮动，清除浮动)
@property (nonatomic) BOOL tg_clearFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_clearFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end




@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置开始位置的快捷方法。
/// \param point 左上角原点的位置
///
- (void)tg_origin:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_origin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// \param point 右下角的结束位置
///
- (void)tg_end:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_end(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 同时设置tg_width和tg_height的简化方法。
/// \param size 宽度和高度值
///
- (void)tg_size:(CGSize)size SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_size(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 四周边距或者间距设置的简化方法
/// \param val 距离父视图四周的边距或者兄弟视图四周间距的值
///
- (void)tg_margin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_margin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 水平边距或者间距设置的简化方法
/// \param val 距离父视图左右水平边距或者兄弟视图左右间距的值
///
- (void)tg_horzMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_horzMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 垂直边距或者间距设置的简化方法
/// \param val 距离父视图上下垂直边距或者兄弟视图上下间距的值
///
- (void)tg_vertMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_vertMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图的在父布局视图调用完评估尺寸的方法后，可以通过这个方法来获取评估的CGRect值。评估的CGRect值是在布局前评估计算的值，而frame则是视图真正完成布局后的真实的CGRect值。在调用这个方法前请先调用父布局视图的tg_sizeThatFits方法进行布局视图的尺寸评估，否则此方法返回的值未可知。这个方法主要用于在视图布局前而想得到其在父布局视图中的位置和尺寸的场景。
@property (nonatomic, readonly) CGRect tg_estimatedFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_estimatedFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图在父布局视图中布局完成后也就是视图的frame更新完成后执行的block，执行完block后会被重置为nil。通过在tg_layoutCompletedDo中我们可以得到这个视图真实的frame值,当然您也可以在里面进行其他业务逻辑的操作和属性的获取和更新。block方法中layout参数就是父布局视图，而v就是视图本身，block中这两个参数目的是为了防止循环引用的问题。
/// \param action 布局完成执行的action
///
- (void)tg_layoutCompletedDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, UIView * _Nonnull))action SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_layoutCompletedDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end


@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置视图不受布局父视图的布局约束控制和不再参与视图的布局，所有设置的其他扩展属性都将失效而必须用frame来设置视图的位置和尺寸，默认值是false。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_useFrame = true
/// 那么在布局完成后：
/// A.frame == {0, 0, 100, 100}
/// B.frame == {20,20,200,100}   //可以看出B并没有受到约束的限制，结果就是B设置的frame值。
/// C.frame == {0, 100,100,200}  //因为B不再参与布局了，所以C就往上移动了，由原来的150变为了100.
/// tg_useFrame的应用场景是某个视图虽然是布局视图的子视图但不想受到父布局视图的约束，而是可以通过frame进行自由位置和尺寸调整的场景。
@property (nonatomic) BOOL tg_useFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_useFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置视图在进行布局时只会参与布局但不会真实的调整位置和尺寸，默认值是false。当设置为YES时会在布局时保留出视图的布局位置和布局尺寸的空间，但不会更新视图的位置和尺寸，也就是说只会占位但不会更新。因此你可以通过frame值来进行位置和尺寸的任意设置，而不会受到你的布局视图的影响。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_noLayout = true
/// 那么在布局完成后：
/// A.frame == {0,0,100,100}
/// B.frame == {20,20,200,100}  //可以看出虽然B参与了布局，但是并没有更新B的frame值，而是保持为通过frame设置的原始值。
/// C.frame == {0,150,100,200}  //因为B参与了布局，占用了50的高度，所以这里C的位置还是150，而不是100.
/// tg_useFrame和tg_noLayout的区别是：
/// <ol>
///   <li>
///     前者不会参与布局而必须要通过frame值进行设置，而后者则会参与布局但是不会将布局的结果更新到frame中。
///   </li>
///   <li>
///     当前者设置为true时后者的设置将无效，而后者的设置并不会影响前者的设置。
///   </li>
/// </ol>
/// tg_noLayout的应用场景是那些想在运行时动态调整某个视图的位置和尺寸，但是又不想破坏布局视图中其他子视图的布局结构的场景，也就是调整了视图的位置和尺寸，但是不会调整其他的兄弟子视图的位置和尺寸。
@property (nonatomic) BOOL tg_noLayout SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_noLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif

#else
#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.2.2 (swiftlang-1103.0.32.6 clang-1103.0.32.51)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="TangramKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIWindow;
@protocol NSObject;
@class UIColor;
@class UIImage;
@class UITraitCollection;
@class UITouch;
@class UIEvent;
@class NSCoder;

/// 布局视图基类，基类不支持实例化对象。在编程时我们经常会用到一些视图，这种视图只是负责将里面的子视图按照某种规则进行排列和布局，而别无其他的作用。因此我们称这种视图为容器视图或者称为布局视图。
/// 布局视图通过重载layoutSubviews方法来完成子视图的布局和排列的工作。对于每个加入到布局视图中的子视图，都会在加入时通过KVO机制监控子视图的center和bounds以及frame值的变化，每当子视图的这些属性一变化时就又会重新引发布局视图的布局动作。同时对每个视图的布局扩展属性的设置以及对布局视图的布局属性的设置都会引发布局视图的布局动作。布局视图在添加到非布局父视图时也会通过KVO机制来监控非布局父视图的frame值和bounds值，这样每当非布局父视图的尺寸变更时也会引发布局视图的布局动作。前面说的引起变动的方法就是会在KVO处理逻辑以及布局扩展属性和布局属性设置完毕后通过调用setNeedLayout来实现的，当布局视图收到setNeedLayout的请求后，会在下一个runloop中对布局视图进行重新布局而这就是通过调用layoutSubviews方法来实现的。布局视图基类只提供了更新所有子视图的位置和尺寸以及一些基础的设置，而至于如何排列和布局这些子视图则要根据应用的场景和需求来确定，因此布局基类视图提供了一个：
/// internal func tgCalcLayoutRect(_ size:CGSize, isEstimate:Bool, hasSubLayout:inout Bool!, sbs:[UIView]!, type:TGSizeClassType) ->CGSize
/// 的方法，要求派生类去重载这个方法，这样不同的派生类就可以实现不同的应用场景，这就是布局视图的核心实现机制。
/// TangramKit布局库根据实际中常见的场景实现了7种不同的布局视图派生类他们分别是：线性布局、表格布局、相对布局、框架布局、流式布局、浮动布局、路径布局。
SWIFT_CLASS("_TtC10TangramKit12TGBaseLayout")
@interface TGBaseLayout : UIView
/// 用于实现对阿拉伯国家的布局适配。对于非阿拉伯国家来说，界面布局都是默认从左到右排列。而对于阿拉伯国家来说界面布局则默认是从右往左排列。默认这个属性是NO，您可以将这个属性设置为YES，这样布局里面的所有视图都将从右到左进行排列布局。如果您需要考虑国际化布局的问题，那么您应该用tg_leading来表示头部的位置，而用tg_trailing来表示尾部的位置，这样当布局方向是LTR时那么tg_leading就表示的是左边而tg_trailing则表示的是右边；而当布局方向是RTL时那么tg_leading表示的是右边而tg_trailing则表示的是左边。如果您的界面布局不会考虑到国际化以及不需要考虑RTL时那么您可以用tg_left和tg_right来表示左右而不需要用tg_leading和tg_trailing。
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL tg_isRTL SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");)
+ (BOOL)tg_isRTL SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)setTg_isRTL:(BOOL)newValue SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)tg_updateRTL:(BOOL)isRTL inWindow:(UIWindow * _Nonnull)window SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_updateRTL(_:inWindow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图四周的内边距值。所谓内边距是指布局视图内的所有子视图离布局视图四周的边距。通过为布局视图设置内边距可以减少为所有子视图设置外边距的工作，而外边距则是指视图离父视图四周的距离。
@property (nonatomic) UIEdgeInsets tg_padding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_padding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 顶部内边距
@property (nonatomic) CGFloat tg_topPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_topPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 头部内边距，用来设置子视图离自身头部的边距值。对于LTR方向的布局来说就是指的左边内边距，而对于RTL方向的布局来说就是指的右边内边距。
@property (nonatomic) CGFloat tg_leadingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leadingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 底部内边距
@property (nonatomic) CGFloat tg_bottomPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_bottomPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 尾部内边距，用来设置子视图离自身尾部的边距值。对于LTR方向的布局来说就是指的右边内边距，而对于RTL方向的布局来说就是指的左边内边距。
@property (nonatomic) CGFloat tg_trailingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_trailingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 左边内边距。
@property (nonatomic) CGFloat tg_leftPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leftPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 右边内边距
@property (nonatomic) CGFloat tg_rightPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_rightPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置当布局的尺寸由子视图决定并且在没有子视图的情况下tg_padding的设置值是否会加入到布局的尺寸值里面。默认是true，表示当布局视图没有子视图时tg_padding值也会加入到尺寸里面。
/// 举例来说假设某个布局视图的高度是.wrap,并且设置了tg_topPadding为10，tg_bottomPadding为20。那么默认情况下当没有任何子视图时布局视图的高度是30；而当我们将这个属性设置为false时，那么在没有任何子视图时布局视图的高度就是0，也就是说tg_padding不会参与高度的计算了。
@property (nonatomic) BOOL tg_zeroPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_zeroPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 指定padding内边距的缩进是在SafeArea基础之上进行的。默认是.all表示四周都会缩进SafeArea所指定的区域。你也可以设置只缩进某一个或则几个方向，或者不缩进任何一个方向。这个属性是为了支持iPoneX而设置的。为了支持iPhoneX的全屏幕适配。我们只需要对根布局视图设置这个扩展属性，默认情况下是不需要进行特殊设置的，TangramKit自动会对iPhoneX进行适配。我们知道iOS11中引入了安全区域的概念，TangramKit中的根布局视图会自动将安全区域叠加到设置的padding中去。默认情况下左右的安全区域都会叠加到padding中去，因此您可以根据特殊情况来设置只需要叠加哪一个方向的安全区域。
@property (nonatomic) UIRectEdge tg_insetsPaddingFromSafeArea SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetsPaddingFromSafeArea' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *当tg_insetsPaddingFromSafeArea同时设置有左右方向同时缩进并且在横屏时是否只缩进有刘海方向的内边距。默认是false，表示两边都会缩进。如果你想让没有刘海的那一边延伸到屏幕的安全区外，请将这个属性设置为true。iPhoneX设备中具有一个尺寸为44的刘海区域。当您横屏时为了对齐，左右两边的安全缩进区域都是44。但是有些时候我们希望没有刘海的那一边不需要缩进对齐而是延伸到安全区域以外。这时候您可以通过给根布局视图设置这个属性来达到效果。注意这个属性只有tg_insetsPaddingFromSafeArea设置了左右都缩进时才有效。
@property (nonatomic) BOOL tg_insetLandscapeFringePadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetLandscapeFringePadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的间距，所谓间距就是子视图之间的间隔距离。
@property (nonatomic) CGFloat tg_space SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_space' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的上下垂直间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_vspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_vspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的左右水平间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_hspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_hspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 布局里面的所有子视图按添加的顺序逆序进行布局。默认是false，表示按子视图添加的顺序排列。比如一个垂直线性布局依次添加A,B,C三个子视图，那么在布局时则A,B,C从上到下依次排列。当这个属性设置为YES时，则布局时C,B,A依次从上到下排列。
@property (nonatomic) BOOL tg_reverseLayout SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_reverseLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGAffineTransform tg_layoutTransform SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_layoutTransform' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在布局视图进行布局时是否调用基类的layoutSubviews方法，默认设置为false。
@property (nonatomic) BOOL tg_priorAutoresizingMask SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_priorAutoresizingMask' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回当前布局视图是否正在执行布局。
@property (nonatomic, readonly) BOOL tg_isLayouting SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isLayouting' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置是否选中状态。您可以用这个状态来记录布局的扩展属性。
@property (nonatomic) BOOL isSelected SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.isSelected' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除所有子视图
- (void)tg_removeAllSubviews SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_removeAllSubviews()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 执行布局动画。在布局视图的某个子视图设置完布局属性后，调用布局的这个方法可以让布局里面的子视图在布局时实现动画效果。
/// \param duration 动画时长
///
- (void)tg_layoutAnimationWithDuration:(NSTimeInterval)duration SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_layoutAnimationWithDuration(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 是否缓存经过tg_sizeThatFits方法评估后的所有子视图的位置和尺寸一次!，默认设置为false不缓存。当我们用tg_sizeThatFits方法评估布局视图的尺寸后，所有子视图都会生成评估的位置和尺寸，因为此时并没有执行布局所以子视图并没有真实的更新frame值。而当布局视图要进行真实布局时又会重新计算所有子视图的位置和尺寸，因此为了优化性能当我们对布局进行评估后在下次真实布局时我们可以不再重新计算子视图的位置和尺寸而是用前面评估的值来设置位置和尺寸。这个属性设置为true时则每次评估后到下一次布局时不会再重新计算子视图的布局了，而是用评估值来布局子视图的位置和尺寸。而当这个属性设置为false时则每次布局都会重新计算子视图的位置和布局。
/// 这个属性一般用在那些动态高度UITableviewCell中进行配合使用，我们一般将布局视图作为UITableviewCell的contentView的子视图:
/// let rootLayout= TGXXXLayout()
/// rootLayout.tg_cacheEstimatedRect = true   //设置缓存评估的rect,如果您的cell是高度自适应的话，强烈建立打开这个属性，这会大大的增强您的tableview的性能！！
/// rootLayout.tg_width.equal(.fill)           //宽度和父视图相等
/// rootLayout.tg_height.equal(.wrap)    //高度动态包裹。
/// self.contentView.addSubview(rootLayout)
/// self.rootLayout = rootLayout;
/// //在rootLayout添加子视图。。。
/// <hr/>
/// 然后我们在heightForRowAtIndexPath中按如下格式进行高度的评估的计算。
/// override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
/// let cell = self.tableView(tableView,cellForRowAt:indexPath) as! UIXXXTableViewCell
/// let size = cell.rootLayout.tg_sizeThatFits(CGSize(width:tableView.frame.width, height:0))
/// return size.height;
/// }
/// 这个属性有可能会造成动态高度计算不正确，请只在UITableviewCell的高度为自适应时使用，其他地方不建议设置这个属性！！
@property (nonatomic) BOOL tg_cacheEstimatedRect SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_cacheEstimatedRect' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 评估计算一个未加入到布局视图中的子视图subview在加入后的frame值。在实践中我们希望得到某个未加入的子视图在添加到布局视图后的应该具有的frame值，这时候就可以用这个方法来获取。比如我们希望把一个子视图从一个布局视图里面移到另外一个布局视图的末尾时希望能够提供动画效果,这时候就可以通过这个方法来得到加入后的子视图的位置和尺寸。
/// 这个方法只有针对那些通过添加顺序进行约束的布局视图才有意义，相对布局和框架布局则没有意义。
/// 使用示例：假设存在两个布局视图L1,L2他们的父视图是S，现在要实现将L1中的任意一个子视图A移动到L2的末尾中去，而且要带动画效果，那么代码如下：
/// //得到A在S中的frame，这里需要进行坐标转换为S在中的frame
/// let rectOld = L1.convert(A.frame, to: S)
/// //得到将A加入到L2后的评估的frame值，注意这时候A还没有加入到L2。
/// var rectNew = L2.tg_estimatedFrame(of: A)
/// rectNew = L2.convert(rectNew, to: S) //将新位置的评估的frame值，这里需要进行坐标转换为S在中的frame。
/// //动画的过程是先将A作为S的子视图进行位置的调整后再加入到L2中去
/// A.removeFromSuperview()
/// A.frame = rectOld
/// A.tg_useFrame = true  //设置为true表示A不再受到布局视图的约束，而是可以自由设置frame值。
/// S.addSubview(sender)
/// UIView.animate(withDuration: 0.3, animations: {
/// A.frame = rectNew
/// }) { _ in
/// //动画结束后再将A移植到L2中。
/// A.removeFromSuperview()
/// A.tg_useFrame = false  //还原tg_useFrame，因为加入到L2后将受到布局视图的约束。
/// L2.addSubview(A)
/// }
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     subview: 一个未加入布局视图的子视图，如果子视图已经加入则直接返回子视图的frame值。
///   </li>
///   <li>
///     size:指定布局视图期望的宽度或者高度，一般请将这个值设置为.zero。 具体请参考tg_sizeThatFits方法中的size的说明。
///   </li>
/// </ul>
///
/// returns:
/// 子视图在布局视图最后一个位置(假如加入后)的frame值。
- (CGRect)tg_estimatedFrameOf:(UIView * _Nonnull)subview inLayoutSize:(CGSize)size SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_estimatedFrame(of:inLayoutSize:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在布局开始之前和布局完成之后的处理块。系统会在每次布局完成前后分别执行对应的处理块后将处理块清空为nil。您也可以在tg_endLayoutDo块内取到所有子视图真实布局后的frame值。系统会在调用layoutSubviews方法前执行tg_beginLayoutDo，而在layoutSubviews方法执行后执行tg_endLayoutDo。
- (void)tg_beginLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_beginLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_endLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在第一次布局完成之后或者有横竖屏切换时进行处理的动作块。这个block不像tg_beginLayoutDo以及tg_endLayoutDo那样只会执行一次,而是会一直存在
/// 因此需要注意代码块里面的循环引用的问题。这个block调用的时机是第一次布局完成或者每次横竖屏切换时布局完成被调用。
/// 这个方法会在tg_endLayoutDo执行后调用。
/// <ul>
///   <li>
///     layout: 参数就是布局视图本身
///   </li>
///   <li>
///     isFirst: 表明当前是否是第一次布局时调用。
///   </li>
///   <li>
///     isPortrait: 表明当前是横屏还是竖屏。
///   </li>
/// </ul>
- (void)tg_rotationToDeviceOrientationDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, BOOL, BOOL))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_rotationToDeviceOrientationDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 不使用父布局视图提供的智能边界线功能。当布局视图的父布局视图设置了tg_intelligentBorderline时但是布局视图又想自己定义边界线时则将这个属性设置为true
@property (nonatomic) BOOL tg_notUseIntelligentBorderline SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_notUseIntelligentBorderline' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_setTarget:(id <NSObject> _Nullable)target action:(SEL _Nullable)action for:(UIControlEvents)controlEvents SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_setTarget(_:action:for:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时背景的高亮的颜色。只有设置了tg_setTarget方法后此属性才生效。
@property (nonatomic, strong) UIColor * _Null_unspecified tg_highlightedBackgroundColor SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundColor' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮不透明度。值的范围是[0,1]，默认是0表示完全不透明，为1表示完全透明。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic) CGFloat tg_highlightedOpacity SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedOpacity' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局的背景图片。这个属性的设置就是设置了布局的layer.contents的值，因此如果要实现背景图的局部拉伸请用layer.contentsXXX这些属性进行调整
@property (nonatomic, strong) UIImage * _Null_unspecified tg_backgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_backgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮背景图片。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic, strong) UIImage * _Null_unspecified tg_highlightedBackgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)safeAreaInsetsDidChange;
- (void)setNeedsLayout;
@property (nonatomic, readonly) CGSize intrinsicContentSize;
- (void)layoutSubviews;
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
- (CGSize)sizeThatFits:(CGSize)size SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, getter=isHidden) BOOL hidden;
- (void)awakeFromNib;
- (void)didAddSubview:(UIView * _Nonnull)subview;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (void)willMoveToSuperview:(UIView * _Nullable)newSuperview;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// 浮动布局是一种里面的子视图按照约定的方向浮动停靠，当浮动布局的剩余空间不足容纳子视图的尺寸时会自动寻找最佳的位置进行浮动停靠的布局视图。
/// *浮动布局的理念源于HTML/CSS中的浮动定位技术,因此浮动布局可以专门用来实现那些不规则布局或者图文环绕的布局。
/// *根据浮动的方向不同，浮动布局可以分为左右浮动布局和上下浮动布局。我们称左右浮动的浮动布局为垂直浮动布局，因为左右浮动时最终整个方向是从上到下的；称上下浮动的浮动布局为水平浮动布局，因为上下浮动时最终整个方向是从左到右的。
SWIFT_CLASS("_TtC10TangramKit13TGFloatLayout")
@interface TGFloatLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *不做布局边界尺寸的限制，子视图不会自动换行，因此当设置为true时，子视图需要设置tg_clearFloat来实现主动换行的处理。默认为false。
/// *当布局的orientation为.vert并且tg_width.equal(.wrap)时,这个属性设置为true才生效。
/// *当布局的orientation为.horz并且tg_height.equal(.wrap)时，这个属性设置为true才生效。
/// *当属性设置为true时，子视图不能将扩展属性tg_reverseFloat设置为true，否则将导致结果异常。
/// *这个属性设置为true时，在左右浮动布局中，子视图只能向左浮动，并且没有右边界的限制，因此如果子视图没有tg_clearFloat时则总是排列在前一个子视图的右边，并不会自动换行,因此为了让这个属性生效，布局视图必须要同时设置tg_width.equal(.wrap)。
/// *这个属性设置为true时，在上下浮动布局中，子视图只能向上浮动，并且没有下边界的限制，因此如果子视图没有设置tg_clearFloat时则总是排列在前一个子视图的下边，并不会自动换行，因此为了让这个属性生效，布局视图必须要同时设置tg_height.equal(.wrap).
@property (nonatomic) BOOL tg_noBoundaryLimit SWIFT_DEPRECATED_OBJC("Swift property 'TGFloatLayout.tg_noBoundaryLimit' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *流式布局是一种里面的子视图按照添加的顺序依次排列，当遇到某种约束限制后会另起一排再重新排列的多行多列展示的布局视图。这里的约束限制主要有数量约束限制和内容尺寸约束限制两种，排列的方向又分为垂直和水平方向，因此流式布局一共有垂直数量约束流式布局、垂直内容约束流式布局、水平数量约束流式布局、水平内容约束流式布局。流式布局主要应用于那些有规律排列的场景，在某种程度上可以作为UICollectionView的替代品。
/// 1.垂直数量约束流式布局
/// tg_orientation=.vert,tg_arrangedCount>0
/// 每排数量为3的垂直数量约束流式布局
/// =>
/// +——+—+—–+
/// |  A   | B |  C  |
/// +—+–+-+-+—–+
/// | D |  E |   F   |  |
/// +—+-+–+–+––+  v
/// |  G  |  H  | I  |
/// +—–+—–+––+
/// 2.垂直内容约束流式布局.
/// tg_orientation = .vert,tg_arrangedCount = 0
/// 垂直内容约束流式布局
/// =>
/// +—–+———–+
/// |  A  |     B     |
/// +—–+—–+—–+
/// |  C  |  D  |  E  |  |
/// +—–+—–+—–+  v
/// |        F        |
/// +—————–+
/// 3.水平数量约束流式布局。
/// tg_orientation = .horz,tg_arrangedCount > 0
/// 每排数量为3的水平数量约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | D  |     |
/// |     |––|  G  |
/// |—–|    |     |
/// |  |  B  | E  |—–|
/// V  |—–|    |     |
/// |     |––|  H  |
/// |  C  |    |—–|
/// |     | F  |  I  |
/// +—–+––+—–+
/// 4.水平内容约束流式布局
/// tg_orientation = .horz,arrangedCount = 0
/// 水平内容约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | C  |     |
/// |     |––|     |
/// |—–|    |     |
/// |  |     | D  |     |
/// V  |     |    |  F  |
/// |  B  |––|     |
/// |     |    |     |
/// |     | E  |     |
/// +—–+––+—–+
/// 流式布局中排的概念是一个通用的称呼，对于垂直方向的流式布局来说一排就是一行，垂直流式布局每排依次从上到下排列，每排内的子视图则是由左往右依次排列；对于水平方向的流式布局来说一排就是一列，水平流式布局每排依次从左到右排列，每排内的子视图则是由上往下依次排列
SWIFT_CLASS("_TtC10TangramKit12TGFlowLayout")
@interface TGFlowLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *指定方向上的子视图的数量，默认是0表示为内容约束流式布局，当数量不为0时则是数量约束流式布局。当值为0时则表示当子视图在方向上的尺寸超过布局视图时则会新起一排。而如果数量不为0时则：
/// 如果方向为.vert，则表示从左到右的数量，当子视图从左往右满足这个数量后新的子视图将会新起一排
/// 如果方向为.horz，则表示从上到下的数量，当子视图从上往下满足这个数量后新的子视图将会新起一排
@property (nonatomic) NSInteger tg_arrangedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_arrangedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *为流式布局提供分页展示的能力,默认是0表不支持分页展示，当设置为非0时则要求必须是tg_arrangedCount的整数倍数，表示每页的子视图的数量。而tg_arrangedCount则表示每排的子视图的数量。当启用tg_pagedCount时要求将流式布局加入到UIScrollView或者其派生类中才能生效。只有数量约束流式布局才支持分页展示的功能，tg_pagedCount和tg_height.isWrap以及tg_width.isWrap配合使用能实现不同的分页展示能力:
/// 1.垂直数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从左到右再从上到下排列，新页往下滚动继续排列)：
/// 1  2  3
/// 4  5  6
/// —––  ↓
/// 7  8  9
/// 10 11 12
/// 2.垂直数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从左到右再从上到下排列，新页往右滚动继续排列)
/// 1  2  3 | 7  8  9
/// 4  5  6 | 10 11 12
/// →
/// 1.水平数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从上到下再从左到右排列，新页往右滚动继续排列)
/// 1  3  5 | 7  9   11
/// 2  4  6 | 8  10  12
/// →
/// 2.水平数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从上到下再从左到右排列，新页往下滚动继续排列)
/// 1  3  5
/// 2  4  6
/// ——— ↓
/// 7  9  11
/// 8  10 12
@property (nonatomic) NSInteger tg_pagedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_pagedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *子视图自动排列,这个属性只有在内容填充约束流式布局下才有用,默认为false.当设置为YES时则根据子视图的内容自动填充，而不是根据加入的顺序来填充，以便保证不会出现多余空隙的情况。
/// *请在将所有子视图添加完毕并且初始布局完成后再设置这个属性，否则如果预先设置这个属性则在后续添加子视图时非常耗性能。
@property (nonatomic) BOOL tg_autoArrange SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_autoArrange' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *框架布局是一种里面的子视图停靠在父视图特定方位并且可以重叠的布局视图。框架布局里面的子视图的布局位置和添加的顺序无关，只跟父视图建立布局约束依赖关系。
/// *框架布局是一种简化的相对布局。也就是里面子视图的TGLayoutPos对象所设置的值都是距离父布局视图的边距值，里面的TGLayoutSize对象所设置的值都是相对于父视图的尺寸来处理的。
SWIFT_CLASS("_TtC10TangramKit13TGFrameLayout")
@interface TGFrameLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *线性布局是一种里面的子视图按添加的顺序从上到下或者从左到右依次排列的单行(单列)布局视图。线性布局里面的子视图是通过添加的顺序建立约束和依赖关系的。
/// *根据排列的方向我们把子视图从上到下依次排列的线性布局视图称为垂直线性布局视图，而把子视图从左到右依次排列的线性布局视图则称为水平线性布局。
/// 垂直线性布局
/// +—––+
/// |   A   |
/// +—––+
/// |   B   |
/// +—––+  ⥥
/// |   C   |
/// +—––+
/// |  …  |
/// +—––+
/// 水平线性布局
/// +—–+—–+—–+—–+
/// |  A  |  B  |  C  | … |
/// +—–+—–+—–+—–+
/// ⥤
SWIFT_CLASS("_TtC10TangramKit14TGLinearLayout")
@interface TGLinearLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// 设置水平线性布局里面的基线对齐基准视图，所有其他子视图的基线都以这个为准。
/// 这个属性要和tg_gravity属性设置为TGGravity.vert.baseline配合使用。并且要求这个属性所指定的视图，必须具有font属性。
/// 目前支持具有font属性的有UILabel，UITextField,UITextView, UIButton几个系统控件。
@property (nonatomic, strong) UIView * _Null_unspecified tg_baselineBaseView SWIFT_DEPRECATED_OBJC("Swift property 'TGLinearLayout.tg_baselineBaseView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *路径布局类。路径布局通过坐标轴的设置，曲线路径函数方程，子视图中心点之间的距离三个要素来确定其中子视图的位置。因此通过路径布局可以实现一些非常酷炫的布局效果。
SWIFT_CLASS("_TtC10TangramKit12TGPathLayout")
@interface TGPathLayout : TGBaseLayout
/// 设置和获取布局视图中的原点视图，默认是nil。如果设置了原点视图则总会将原点视图作为布局视图中的最后一个子视图。原点视图将会显示在路径的坐标原点中心上，因此原点布局是不会参与在路径中的布局的。因为中心原点视图是布局视图中的最后一个子视图，而TGPathLayout重写了addSubview方法，因此可以正常的使用这个方法来添加子视图。
@property (nonatomic, strong) UIView * _Nullable tg_originView SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_originView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回布局视图中所有在曲线路径中排列的子视图。如果设置了原点视图则返回subviews里面除最后一个子视图外的所有子视图，如果没有原点子视图则返回subviews
@property (nonatomic, readonly, copy) NSArray<UIView *> * _Nonnull tg_pathSubviews SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_pathSubviews' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置获取子视图距离的误差值。默认是0.5，误差越小则距离的精确值越大，误差最低值不能<=0。一般不需要调整这个值，只有那些要求精度非常高的场景才需要微调这个值,比如在一些曲线路径较短的情况下，通过调小这个值来子视图之间间距的精确计算。
@property (nonatomic) CGFloat tg_distanceError SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_distanceError' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_beginSubviewPathPointWithFull:(BOOL)full SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_beginSubviewPathPoint(full:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endSubviewPathPoint SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_endSubviewPathPoint()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建从某个子视图到另外一个子视图之间的路径点，返回NSValue数组，里面的值是CGPoint。
/// fromIndex指定开始的子视图的索引位置，toIndex指定结束的子视图的索引位置。如果有原点子视图时,这两个索引值不能算上原点子视图的索引值。
- (NSArray<NSValue *> * _Nullable)tg_getSubviewPathPointFromIndex:(NSInteger)fromIndex toIndex:(NSInteger)toIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_getSubviewPathPoint(fromIndex:toIndex:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建布局的曲线的路径。用户需要负责销毁返回的值。调用者可以用这个方法来获得曲线的路径，进行一些绘制的工作。
/// subviewCount:指定这个路径上子视图的数量的个数，如果设置为-1则是按照布局视图的子视图的数量来创建。需要注意的是如果布局视图的tg_spaceType为.flexed,.count的话则这个参数设置无效。
- (CGPathRef _Nonnull)tg_createPathWithSubviewCount:(NSInteger)subviewCount SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_createPath(subviewCount:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)addSubview:(UIView * _Nonnull)view;
- (void)sendSubviewToBack:(UIView * _Nonnull)view;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *相对布局是一种里面的子视图通过相互之间的约束和依赖来进行布局和定位的布局视图。
/// *相对布局里面的子视图的布局位置和添加的顺序无关，而是通过设置子视图的相对依赖关系来进行定位和布局的。
/// *相对布局提供和AutoLayout等价的功能。
SWIFT_CLASS("_TtC10TangramKit16TGRelativeLayout")
@interface TGRelativeLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *表格布局是一种里面的子视图可以像表格一样进行多行多列排列的布局视图。子视图添加到表格布局视图前必须先要建立并添加行子视图，然后再将列子视图添加到行子视图里面。
/// *表格里面的行子视图和列子视图的排列方向的概念是相对的，他根据表格布局方向的不同而不同。表格布局根据方向可分为垂直表格布局和水平表格布局。
/// *对于垂直表格布局来说，行子视图是从上到下依次排列的，而列子视图则是在行子视图里面从左到右依次排列。
/// *对于水平表格布局来说，行子视图是从左到右依次排列的，而列子视图则是在行子视图里面从上到下依次排列。
SWIFT_CLASS("_TtC10TangramKit13TGTableLayout")
@interface TGTableLayout : TGLinearLayout
/// 删除一行
- (void)tg_removeRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeRow(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两行的位置
- (void)tg_exchangeRow:(NSInteger)rowIndex1 with:(NSInteger)rowIndex2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeRow(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行对象
- (TGLinearLayout * _Nonnull)tg_rowViewAt:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_rowView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行的数量
@property (nonatomic, readonly) NSInteger tg_rowCount SWIFT_DEPRECATED_OBJC("Swift property 'TGTableLayout.tg_rowCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 添加一个新的列。再添加一个新的列前必须要先添加行，对于垂直表格来说每一列是从左到右排列的，而对于水平表格来说每一列是从上到下排列的。
/// @colView:  列视图
/// @rowIndex: 指定要添加列的行的索引
- (void)tg_addCol:(UIView * _Nonnull)colView inRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_addCol(_:inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在指定的indexPath下插入一个新的列 IndexPath(row:1, col:1)
- (void)tg_insertCol:(UIView * _Nonnull)colView inIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_insertCol(_:inIndexPath:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除一列
- (void)tg_removeCol:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeCol(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两个列视图，这两个列视图是可以跨行的
- (void)tg_exchangeCol:(NSIndexPath * _Nonnull)indexPath1 with:(NSIndexPath * _Nonnull)indexPath2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeCol(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回列视图
- (UIView * _Nonnull)tg_colViewAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回某行的列的数量
- (NSInteger)tg_colCountInRow:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colCount(inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGFloat tg_vspace;
@property (nonatomic) CGFloat tg_hspace;
/// *表格布局的addSubView被重新定义，是addCol:atRow的精简版本，表示插入当前行的最后一列
- (void)addSubview:(UIView * _Nonnull)view;
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
- (void)insertSubview:(UIView * _Nonnull)view belowSubview:(UIView * _Nonnull)siblingSubview;
- (void)insertSubview:(UIView * _Nonnull)view aboveSubview:(UIView * _Nonnull)siblingSubview;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end






@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 是否反方向浮动，默认是false表示正向浮动，正向浮动和反向浮动的意义根据所在的父浮动布局视图的方向的不同而不同：
/// 1.如果父视图是垂直浮动布局则默认正向浮动是向左浮动的，而反向浮动则是向右浮动。
/// 2.如果父视图是水平浮动布局则默认正向浮动是向上浮动的，而反向浮动则是向下浮动。
/// 下面是垂直浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F)：
/// |<–A– <—B—    -C->|
/// |<—–D–– -F-> –E–>|
/// 下面是水平浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F):
/// <hr/>
/// <h2>↑   ↑
/// |   |
/// A   |
/// |   D
/// |
/// ↑   |
/// B
/// |   F
/// ↓
/// |   |
/// C   E
/// ↓   ↓</h2>
@property (nonatomic) BOOL tg_reverseFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_reverseFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *清除浮动，默认是false。这个属性的意义也跟父浮动布局视图的方向相关。如果设置为了清除浮动属性则表示本视图不会在浮动方向上紧跟在前一个浮动视图的后面，而是会另外新起一行或者一列来重新排列。tg_reverseFloat和tg_clearFloat这两个属性的定义是完全参考CSS样式表中浮动布局中的float和clear这两个属性。
/// 垂直浮动布局下的浮动和清除浮动
/// |<–A– <—B— <-C–|
/// |<––D—            |
/// |<–E– <—F–       |
/// |<—–G––          |
/// |      —I—> –H–>|
/// |                -J-> |
/// A(正向浮动);B(正向浮动);C(正向浮动);D(正向浮动);E(正向浮动);F(正向浮动);G(正向浮动，清除浮动);H(反向浮动);I(反向浮动);J(反向浮动，清除浮动)
@property (nonatomic) BOOL tg_clearFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_clearFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end




@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置开始位置的快捷方法。
/// \param point 左上角原点的位置
///
- (void)tg_origin:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_origin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// \param point 右下角的结束位置
///
- (void)tg_end:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_end(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 同时设置tg_width和tg_height的简化方法。
/// \param size 宽度和高度值
///
- (void)tg_size:(CGSize)size SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_size(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 四周边距或者间距设置的简化方法
/// \param val 距离父视图四周的边距或者兄弟视图四周间距的值
///
- (void)tg_margin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_margin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 水平边距或者间距设置的简化方法
/// \param val 距离父视图左右水平边距或者兄弟视图左右间距的值
///
- (void)tg_horzMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_horzMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 垂直边距或者间距设置的简化方法
/// \param val 距离父视图上下垂直边距或者兄弟视图上下间距的值
///
- (void)tg_vertMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_vertMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图的在父布局视图调用完评估尺寸的方法后，可以通过这个方法来获取评估的CGRect值。评估的CGRect值是在布局前评估计算的值，而frame则是视图真正完成布局后的真实的CGRect值。在调用这个方法前请先调用父布局视图的tg_sizeThatFits方法进行布局视图的尺寸评估，否则此方法返回的值未可知。这个方法主要用于在视图布局前而想得到其在父布局视图中的位置和尺寸的场景。
@property (nonatomic, readonly) CGRect tg_estimatedFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_estimatedFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图在父布局视图中布局完成后也就是视图的frame更新完成后执行的block，执行完block后会被重置为nil。通过在tg_layoutCompletedDo中我们可以得到这个视图真实的frame值,当然您也可以在里面进行其他业务逻辑的操作和属性的获取和更新。block方法中layout参数就是父布局视图，而v就是视图本身，block中这两个参数目的是为了防止循环引用的问题。
/// \param action 布局完成执行的action
///
- (void)tg_layoutCompletedDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, UIView * _Nonnull))action SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_layoutCompletedDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end


@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置视图不受布局父视图的布局约束控制和不再参与视图的布局，所有设置的其他扩展属性都将失效而必须用frame来设置视图的位置和尺寸，默认值是false。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_useFrame = true
/// 那么在布局完成后：
/// A.frame == {0, 0, 100, 100}
/// B.frame == {20,20,200,100}   //可以看出B并没有受到约束的限制，结果就是B设置的frame值。
/// C.frame == {0, 100,100,200}  //因为B不再参与布局了，所以C就往上移动了，由原来的150变为了100.
/// tg_useFrame的应用场景是某个视图虽然是布局视图的子视图但不想受到父布局视图的约束，而是可以通过frame进行自由位置和尺寸调整的场景。
@property (nonatomic) BOOL tg_useFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_useFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置视图在进行布局时只会参与布局但不会真实的调整位置和尺寸，默认值是false。当设置为YES时会在布局时保留出视图的布局位置和布局尺寸的空间，但不会更新视图的位置和尺寸，也就是说只会占位但不会更新。因此你可以通过frame值来进行位置和尺寸的任意设置，而不会受到你的布局视图的影响。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_noLayout = true
/// 那么在布局完成后：
/// A.frame == {0,0,100,100}
/// B.frame == {20,20,200,100}  //可以看出虽然B参与了布局，但是并没有更新B的frame值，而是保持为通过frame设置的原始值。
/// C.frame == {0,150,100,200}  //因为B参与了布局，占用了50的高度，所以这里C的位置还是150，而不是100.
/// tg_useFrame和tg_noLayout的区别是：
/// <ol>
///   <li>
///     前者不会参与布局而必须要通过frame值进行设置，而后者则会参与布局但是不会将布局的结果更新到frame中。
///   </li>
///   <li>
///     当前者设置为true时后者的设置将无效，而后者的设置并不会影响前者的设置。
///   </li>
/// </ol>
/// tg_noLayout的应用场景是那些想在运行时动态调整某个视图的位置和尺寸，但是又不想破坏布局视图中其他子视图的布局结构的场景，也就是调整了视图的位置和尺寸，但是不会调整其他的兄弟子视图的位置和尺寸。
@property (nonatomic) BOOL tg_noLayout SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_noLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#elif defined(__ARM_ARCH_7A__) && __ARM_ARCH_7A__
// Generated by Apple Swift version 5.2.2 (swiftlang-1103.0.32.6 clang-1103.0.32.51)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="TangramKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class UIWindow;
@protocol NSObject;
@class UIColor;
@class UIImage;
@class UITraitCollection;
@class UITouch;
@class UIEvent;
@class NSCoder;

/// 布局视图基类，基类不支持实例化对象。在编程时我们经常会用到一些视图，这种视图只是负责将里面的子视图按照某种规则进行排列和布局，而别无其他的作用。因此我们称这种视图为容器视图或者称为布局视图。
/// 布局视图通过重载layoutSubviews方法来完成子视图的布局和排列的工作。对于每个加入到布局视图中的子视图，都会在加入时通过KVO机制监控子视图的center和bounds以及frame值的变化，每当子视图的这些属性一变化时就又会重新引发布局视图的布局动作。同时对每个视图的布局扩展属性的设置以及对布局视图的布局属性的设置都会引发布局视图的布局动作。布局视图在添加到非布局父视图时也会通过KVO机制来监控非布局父视图的frame值和bounds值，这样每当非布局父视图的尺寸变更时也会引发布局视图的布局动作。前面说的引起变动的方法就是会在KVO处理逻辑以及布局扩展属性和布局属性设置完毕后通过调用setNeedLayout来实现的，当布局视图收到setNeedLayout的请求后，会在下一个runloop中对布局视图进行重新布局而这就是通过调用layoutSubviews方法来实现的。布局视图基类只提供了更新所有子视图的位置和尺寸以及一些基础的设置，而至于如何排列和布局这些子视图则要根据应用的场景和需求来确定，因此布局基类视图提供了一个：
/// internal func tgCalcLayoutRect(_ size:CGSize, isEstimate:Bool, hasSubLayout:inout Bool!, sbs:[UIView]!, type:TGSizeClassType) ->CGSize
/// 的方法，要求派生类去重载这个方法，这样不同的派生类就可以实现不同的应用场景，这就是布局视图的核心实现机制。
/// TangramKit布局库根据实际中常见的场景实现了7种不同的布局视图派生类他们分别是：线性布局、表格布局、相对布局、框架布局、流式布局、浮动布局、路径布局。
SWIFT_CLASS("_TtC10TangramKit12TGBaseLayout")
@interface TGBaseLayout : UIView
/// 用于实现对阿拉伯国家的布局适配。对于非阿拉伯国家来说，界面布局都是默认从左到右排列。而对于阿拉伯国家来说界面布局则默认是从右往左排列。默认这个属性是NO，您可以将这个属性设置为YES，这样布局里面的所有视图都将从右到左进行排列布局。如果您需要考虑国际化布局的问题，那么您应该用tg_leading来表示头部的位置，而用tg_trailing来表示尾部的位置，这样当布局方向是LTR时那么tg_leading就表示的是左边而tg_trailing则表示的是右边；而当布局方向是RTL时那么tg_leading表示的是右边而tg_trailing则表示的是左边。如果您的界面布局不会考虑到国际化以及不需要考虑RTL时那么您可以用tg_left和tg_right来表示左右而不需要用tg_leading和tg_trailing。
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL tg_isRTL SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");)
+ (BOOL)tg_isRTL SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)setTg_isRTL:(BOOL)newValue SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isRTL' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
+ (void)tg_updateRTL:(BOOL)isRTL inWindow:(UIWindow * _Nonnull)window SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_updateRTL(_:inWindow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图四周的内边距值。所谓内边距是指布局视图内的所有子视图离布局视图四周的边距。通过为布局视图设置内边距可以减少为所有子视图设置外边距的工作，而外边距则是指视图离父视图四周的距离。
@property (nonatomic) UIEdgeInsets tg_padding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_padding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 顶部内边距
@property (nonatomic) CGFloat tg_topPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_topPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 头部内边距，用来设置子视图离自身头部的边距值。对于LTR方向的布局来说就是指的左边内边距，而对于RTL方向的布局来说就是指的右边内边距。
@property (nonatomic) CGFloat tg_leadingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leadingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 底部内边距
@property (nonatomic) CGFloat tg_bottomPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_bottomPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 尾部内边距，用来设置子视图离自身尾部的边距值。对于LTR方向的布局来说就是指的右边内边距，而对于RTL方向的布局来说就是指的左边内边距。
@property (nonatomic) CGFloat tg_trailingPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_trailingPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 左边内边距。
@property (nonatomic) CGFloat tg_leftPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_leftPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 右边内边距
@property (nonatomic) CGFloat tg_rightPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_rightPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置当布局的尺寸由子视图决定并且在没有子视图的情况下tg_padding的设置值是否会加入到布局的尺寸值里面。默认是true，表示当布局视图没有子视图时tg_padding值也会加入到尺寸里面。
/// 举例来说假设某个布局视图的高度是.wrap,并且设置了tg_topPadding为10，tg_bottomPadding为20。那么默认情况下当没有任何子视图时布局视图的高度是30；而当我们将这个属性设置为false时，那么在没有任何子视图时布局视图的高度就是0，也就是说tg_padding不会参与高度的计算了。
@property (nonatomic) BOOL tg_zeroPadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_zeroPadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 指定padding内边距的缩进是在SafeArea基础之上进行的。默认是.all表示四周都会缩进SafeArea所指定的区域。你也可以设置只缩进某一个或则几个方向，或者不缩进任何一个方向。这个属性是为了支持iPoneX而设置的。为了支持iPhoneX的全屏幕适配。我们只需要对根布局视图设置这个扩展属性，默认情况下是不需要进行特殊设置的，TangramKit自动会对iPhoneX进行适配。我们知道iOS11中引入了安全区域的概念，TangramKit中的根布局视图会自动将安全区域叠加到设置的padding中去。默认情况下左右的安全区域都会叠加到padding中去，因此您可以根据特殊情况来设置只需要叠加哪一个方向的安全区域。
@property (nonatomic) UIRectEdge tg_insetsPaddingFromSafeArea SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetsPaddingFromSafeArea' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *当tg_insetsPaddingFromSafeArea同时设置有左右方向同时缩进并且在横屏时是否只缩进有刘海方向的内边距。默认是false，表示两边都会缩进。如果你想让没有刘海的那一边延伸到屏幕的安全区外，请将这个属性设置为true。iPhoneX设备中具有一个尺寸为44的刘海区域。当您横屏时为了对齐，左右两边的安全缩进区域都是44。但是有些时候我们希望没有刘海的那一边不需要缩进对齐而是延伸到安全区域以外。这时候您可以通过给根布局视图设置这个属性来达到效果。注意这个属性只有tg_insetsPaddingFromSafeArea设置了左右都缩进时才有效。
@property (nonatomic) BOOL tg_insetLandscapeFringePadding SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_insetLandscapeFringePadding' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的间距，所谓间距就是子视图之间的间隔距离。
@property (nonatomic) CGFloat tg_space SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_space' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的上下垂直间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_vspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_vspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 定义布局视图内子视图之间的左右水平间距。只有顺序布局这个属性才有意义。
@property (nonatomic) CGFloat tg_hspace SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_hspace' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 布局里面的所有子视图按添加的顺序逆序进行布局。默认是false，表示按子视图添加的顺序排列。比如一个垂直线性布局依次添加A,B,C三个子视图，那么在布局时则A,B,C从上到下依次排列。当这个属性设置为YES时，则布局时C,B,A依次从上到下排列。
@property (nonatomic) BOOL tg_reverseLayout SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_reverseLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGAffineTransform tg_layoutTransform SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_layoutTransform' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在布局视图进行布局时是否调用基类的layoutSubviews方法，默认设置为false。
@property (nonatomic) BOOL tg_priorAutoresizingMask SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_priorAutoresizingMask' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回当前布局视图是否正在执行布局。
@property (nonatomic, readonly) BOOL tg_isLayouting SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_isLayouting' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置是否选中状态。您可以用这个状态来记录布局的扩展属性。
@property (nonatomic) BOOL isSelected SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.isSelected' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除所有子视图
- (void)tg_removeAllSubviews SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_removeAllSubviews()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 执行布局动画。在布局视图的某个子视图设置完布局属性后，调用布局的这个方法可以让布局里面的子视图在布局时实现动画效果。
/// \param duration 动画时长
///
- (void)tg_layoutAnimationWithDuration:(NSTimeInterval)duration SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_layoutAnimationWithDuration(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 是否缓存经过tg_sizeThatFits方法评估后的所有子视图的位置和尺寸一次!，默认设置为false不缓存。当我们用tg_sizeThatFits方法评估布局视图的尺寸后，所有子视图都会生成评估的位置和尺寸，因为此时并没有执行布局所以子视图并没有真实的更新frame值。而当布局视图要进行真实布局时又会重新计算所有子视图的位置和尺寸，因此为了优化性能当我们对布局进行评估后在下次真实布局时我们可以不再重新计算子视图的位置和尺寸而是用前面评估的值来设置位置和尺寸。这个属性设置为true时则每次评估后到下一次布局时不会再重新计算子视图的布局了，而是用评估值来布局子视图的位置和尺寸。而当这个属性设置为false时则每次布局都会重新计算子视图的位置和布局。
/// 这个属性一般用在那些动态高度UITableviewCell中进行配合使用，我们一般将布局视图作为UITableviewCell的contentView的子视图:
/// let rootLayout= TGXXXLayout()
/// rootLayout.tg_cacheEstimatedRect = true   //设置缓存评估的rect,如果您的cell是高度自适应的话，强烈建立打开这个属性，这会大大的增强您的tableview的性能！！
/// rootLayout.tg_width.equal(.fill)           //宽度和父视图相等
/// rootLayout.tg_height.equal(.wrap)    //高度动态包裹。
/// self.contentView.addSubview(rootLayout)
/// self.rootLayout = rootLayout;
/// //在rootLayout添加子视图。。。
/// <hr/>
/// 然后我们在heightForRowAtIndexPath中按如下格式进行高度的评估的计算。
/// override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
/// let cell = self.tableView(tableView,cellForRowAt:indexPath) as! UIXXXTableViewCell
/// let size = cell.rootLayout.tg_sizeThatFits(CGSize(width:tableView.frame.width, height:0))
/// return size.height;
/// }
/// 这个属性有可能会造成动态高度计算不正确，请只在UITableviewCell的高度为自适应时使用，其他地方不建议设置这个属性！！
@property (nonatomic) BOOL tg_cacheEstimatedRect SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_cacheEstimatedRect' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 评估计算一个未加入到布局视图中的子视图subview在加入后的frame值。在实践中我们希望得到某个未加入的子视图在添加到布局视图后的应该具有的frame值，这时候就可以用这个方法来获取。比如我们希望把一个子视图从一个布局视图里面移到另外一个布局视图的末尾时希望能够提供动画效果,这时候就可以通过这个方法来得到加入后的子视图的位置和尺寸。
/// 这个方法只有针对那些通过添加顺序进行约束的布局视图才有意义，相对布局和框架布局则没有意义。
/// 使用示例：假设存在两个布局视图L1,L2他们的父视图是S，现在要实现将L1中的任意一个子视图A移动到L2的末尾中去，而且要带动画效果，那么代码如下：
/// //得到A在S中的frame，这里需要进行坐标转换为S在中的frame
/// let rectOld = L1.convert(A.frame, to: S)
/// //得到将A加入到L2后的评估的frame值，注意这时候A还没有加入到L2。
/// var rectNew = L2.tg_estimatedFrame(of: A)
/// rectNew = L2.convert(rectNew, to: S) //将新位置的评估的frame值，这里需要进行坐标转换为S在中的frame。
/// //动画的过程是先将A作为S的子视图进行位置的调整后再加入到L2中去
/// A.removeFromSuperview()
/// A.frame = rectOld
/// A.tg_useFrame = true  //设置为true表示A不再受到布局视图的约束，而是可以自由设置frame值。
/// S.addSubview(sender)
/// UIView.animate(withDuration: 0.3, animations: {
/// A.frame = rectNew
/// }) { _ in
/// //动画结束后再将A移植到L2中。
/// A.removeFromSuperview()
/// A.tg_useFrame = false  //还原tg_useFrame，因为加入到L2后将受到布局视图的约束。
/// L2.addSubview(A)
/// }
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     subview: 一个未加入布局视图的子视图，如果子视图已经加入则直接返回子视图的frame值。
///   </li>
///   <li>
///     size:指定布局视图期望的宽度或者高度，一般请将这个值设置为.zero。 具体请参考tg_sizeThatFits方法中的size的说明。
///   </li>
/// </ul>
///
/// returns:
/// 子视图在布局视图最后一个位置(假如加入后)的frame值。
- (CGRect)tg_estimatedFrameOf:(UIView * _Nonnull)subview inLayoutSize:(CGSize)size SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_estimatedFrame(of:inLayoutSize:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在布局开始之前和布局完成之后的处理块。系统会在每次布局完成前后分别执行对应的处理块后将处理块清空为nil。您也可以在tg_endLayoutDo块内取到所有子视图真实布局后的frame值。系统会在调用layoutSubviews方法前执行tg_beginLayoutDo，而在layoutSubviews方法执行后执行tg_endLayoutDo。
- (void)tg_beginLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_beginLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endLayoutDo:(void (^ _Nullable)(void))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_endLayoutDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局视图在第一次布局完成之后或者有横竖屏切换时进行处理的动作块。这个block不像tg_beginLayoutDo以及tg_endLayoutDo那样只会执行一次,而是会一直存在
/// 因此需要注意代码块里面的循环引用的问题。这个block调用的时机是第一次布局完成或者每次横竖屏切换时布局完成被调用。
/// 这个方法会在tg_endLayoutDo执行后调用。
/// <ul>
///   <li>
///     layout: 参数就是布局视图本身
///   </li>
///   <li>
///     isFirst: 表明当前是否是第一次布局时调用。
///   </li>
///   <li>
///     isPortrait: 表明当前是横屏还是竖屏。
///   </li>
/// </ul>
- (void)tg_rotationToDeviceOrientationDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, BOOL, BOOL))action SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_rotationToDeviceOrientationDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 不使用父布局视图提供的智能边界线功能。当布局视图的父布局视图设置了tg_intelligentBorderline时但是布局视图又想自己定义边界线时则将这个属性设置为true
@property (nonatomic) BOOL tg_notUseIntelligentBorderline SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_notUseIntelligentBorderline' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_setTarget:(id <NSObject> _Nullable)target action:(SEL _Nullable)action for:(UIControlEvents)controlEvents SWIFT_DEPRECATED_OBJC("Swift method 'TGBaseLayout.tg_setTarget(_:action:for:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时背景的高亮的颜色。只有设置了tg_setTarget方法后此属性才生效。
@property (nonatomic, strong) UIColor * _Null_unspecified tg_highlightedBackgroundColor SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundColor' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮不透明度。值的范围是[0,1]，默认是0表示完全不透明，为1表示完全透明。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic) CGFloat tg_highlightedOpacity SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedOpacity' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局的背景图片。这个属性的设置就是设置了布局的layer.contents的值，因此如果要实现背景图的局部拉伸请用layer.contentsXXX这些属性进行调整
@property (nonatomic, strong) UIImage * _Null_unspecified tg_backgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_backgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置布局按下时的高亮背景图片。只有设置了tg_setTarget方法此属性才生效。
@property (nonatomic, strong) UIImage * _Null_unspecified tg_highlightedBackgroundImage SWIFT_DEPRECATED_OBJC("Swift property 'TGBaseLayout.tg_highlightedBackgroundImage' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)safeAreaInsetsDidChange;
- (void)setNeedsLayout;
@property (nonatomic, readonly) CGSize intrinsicContentSize;
- (void)layoutSubviews;
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
- (CGSize)sizeThatFits:(CGSize)size SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, getter=isHidden) BOOL hidden;
- (void)awakeFromNib;
- (void)didAddSubview:(UIView * _Nonnull)subview;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (void)willMoveToSuperview:(UIView * _Nullable)newSuperview;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// 浮动布局是一种里面的子视图按照约定的方向浮动停靠，当浮动布局的剩余空间不足容纳子视图的尺寸时会自动寻找最佳的位置进行浮动停靠的布局视图。
/// *浮动布局的理念源于HTML/CSS中的浮动定位技术,因此浮动布局可以专门用来实现那些不规则布局或者图文环绕的布局。
/// *根据浮动的方向不同，浮动布局可以分为左右浮动布局和上下浮动布局。我们称左右浮动的浮动布局为垂直浮动布局，因为左右浮动时最终整个方向是从上到下的；称上下浮动的浮动布局为水平浮动布局，因为上下浮动时最终整个方向是从左到右的。
SWIFT_CLASS("_TtC10TangramKit13TGFloatLayout")
@interface TGFloatLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *不做布局边界尺寸的限制，子视图不会自动换行，因此当设置为true时，子视图需要设置tg_clearFloat来实现主动换行的处理。默认为false。
/// *当布局的orientation为.vert并且tg_width.equal(.wrap)时,这个属性设置为true才生效。
/// *当布局的orientation为.horz并且tg_height.equal(.wrap)时，这个属性设置为true才生效。
/// *当属性设置为true时，子视图不能将扩展属性tg_reverseFloat设置为true，否则将导致结果异常。
/// *这个属性设置为true时，在左右浮动布局中，子视图只能向左浮动，并且没有右边界的限制，因此如果子视图没有tg_clearFloat时则总是排列在前一个子视图的右边，并不会自动换行,因此为了让这个属性生效，布局视图必须要同时设置tg_width.equal(.wrap)。
/// *这个属性设置为true时，在上下浮动布局中，子视图只能向上浮动，并且没有下边界的限制，因此如果子视图没有设置tg_clearFloat时则总是排列在前一个子视图的下边，并不会自动换行，因此为了让这个属性生效，布局视图必须要同时设置tg_height.equal(.wrap).
@property (nonatomic) BOOL tg_noBoundaryLimit SWIFT_DEPRECATED_OBJC("Swift property 'TGFloatLayout.tg_noBoundaryLimit' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *流式布局是一种里面的子视图按照添加的顺序依次排列，当遇到某种约束限制后会另起一排再重新排列的多行多列展示的布局视图。这里的约束限制主要有数量约束限制和内容尺寸约束限制两种，排列的方向又分为垂直和水平方向，因此流式布局一共有垂直数量约束流式布局、垂直内容约束流式布局、水平数量约束流式布局、水平内容约束流式布局。流式布局主要应用于那些有规律排列的场景，在某种程度上可以作为UICollectionView的替代品。
/// 1.垂直数量约束流式布局
/// tg_orientation=.vert,tg_arrangedCount>0
/// 每排数量为3的垂直数量约束流式布局
/// =>
/// +——+—+—–+
/// |  A   | B |  C  |
/// +—+–+-+-+—–+
/// | D |  E |   F   |  |
/// +—+-+–+–+––+  v
/// |  G  |  H  | I  |
/// +—–+—–+––+
/// 2.垂直内容约束流式布局.
/// tg_orientation = .vert,tg_arrangedCount = 0
/// 垂直内容约束流式布局
/// =>
/// +—–+———–+
/// |  A  |     B     |
/// +—–+—–+—–+
/// |  C  |  D  |  E  |  |
/// +—–+—–+—–+  v
/// |        F        |
/// +—————–+
/// 3.水平数量约束流式布局。
/// tg_orientation = .horz,tg_arrangedCount > 0
/// 每排数量为3的水平数量约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | D  |     |
/// |     |––|  G  |
/// |—–|    |     |
/// |  |  B  | E  |—–|
/// V  |—–|    |     |
/// |     |––|  H  |
/// |  C  |    |—–|
/// |     | F  |  I  |
/// +—–+––+—–+
/// 4.水平内容约束流式布局
/// tg_orientation = .horz,arrangedCount = 0
/// 水平内容约束流式布局
/// =>
/// +—–+––+—–+
/// |  A  | C  |     |
/// |     |––|     |
/// |—–|    |     |
/// |  |     | D  |     |
/// V  |     |    |  F  |
/// |  B  |––|     |
/// |     |    |     |
/// |     | E  |     |
/// +—–+––+—–+
/// 流式布局中排的概念是一个通用的称呼，对于垂直方向的流式布局来说一排就是一行，垂直流式布局每排依次从上到下排列，每排内的子视图则是由左往右依次排列；对于水平方向的流式布局来说一排就是一列，水平流式布局每排依次从左到右排列，每排内的子视图则是由上往下依次排列
SWIFT_CLASS("_TtC10TangramKit12TGFlowLayout")
@interface TGFlowLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// *指定方向上的子视图的数量，默认是0表示为内容约束流式布局，当数量不为0时则是数量约束流式布局。当值为0时则表示当子视图在方向上的尺寸超过布局视图时则会新起一排。而如果数量不为0时则：
/// 如果方向为.vert，则表示从左到右的数量，当子视图从左往右满足这个数量后新的子视图将会新起一排
/// 如果方向为.horz，则表示从上到下的数量，当子视图从上往下满足这个数量后新的子视图将会新起一排
@property (nonatomic) NSInteger tg_arrangedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_arrangedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *为流式布局提供分页展示的能力,默认是0表不支持分页展示，当设置为非0时则要求必须是tg_arrangedCount的整数倍数，表示每页的子视图的数量。而tg_arrangedCount则表示每排的子视图的数量。当启用tg_pagedCount时要求将流式布局加入到UIScrollView或者其派生类中才能生效。只有数量约束流式布局才支持分页展示的功能，tg_pagedCount和tg_height.isWrap以及tg_width.isWrap配合使用能实现不同的分页展示能力:
/// 1.垂直数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从左到右再从上到下排列，新页往下滚动继续排列)：
/// 1  2  3
/// 4  5  6
/// —––  ↓
/// 7  8  9
/// 10 11 12
/// 2.垂直数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从左到右再从上到下排列，新页往右滚动继续排列)
/// 1  2  3 | 7  8  9
/// 4  5  6 | 10 11 12
/// →
/// 1.水平数量约束流式布局的tg_width设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的高度你也可以自定义)，整体的分页滚动是从左到右滚动。(每页布局时从上到下再从左到右排列，新页往右滚动继续排列)
/// 1  3  5 | 7  9   11
/// 2  4  6 | 8  10  12
/// →
/// 2.水平数量约束流式布局的tg_height设置为.wrap时则以UIScrollView的尺寸作为一页展示的大小，因为指定了一页的子视图数量，以及指定了一排的子视图数量，因此默认也会自动计算出子视图的宽度和高度，而不需要单独指出高度和宽度(子视图的宽度你也可以自定义)，整体的分页滚动是从上到下滚动。(每页布局时从上到下再从左到右排列，新页往下滚动继续排列)
/// 1  3  5
/// 2  4  6
/// ——— ↓
/// 7  9  11
/// 8  10 12
@property (nonatomic) NSInteger tg_pagedCount SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_pagedCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *子视图自动排列,这个属性只有在内容填充约束流式布局下才有用,默认为false.当设置为YES时则根据子视图的内容自动填充，而不是根据加入的顺序来填充，以便保证不会出现多余空隙的情况。
/// *请在将所有子视图添加完毕并且初始布局完成后再设置这个属性，否则如果预先设置这个属性则在后续添加子视图时非常耗性能。
@property (nonatomic) BOOL tg_autoArrange SWIFT_DEPRECATED_OBJC("Swift property 'TGFlowLayout.tg_autoArrange' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *框架布局是一种里面的子视图停靠在父视图特定方位并且可以重叠的布局视图。框架布局里面的子视图的布局位置和添加的顺序无关，只跟父视图建立布局约束依赖关系。
/// *框架布局是一种简化的相对布局。也就是里面子视图的TGLayoutPos对象所设置的值都是距离父布局视图的边距值，里面的TGLayoutSize对象所设置的值都是相对于父视图的尺寸来处理的。
SWIFT_CLASS("_TtC10TangramKit13TGFrameLayout")
@interface TGFrameLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *线性布局是一种里面的子视图按添加的顺序从上到下或者从左到右依次排列的单行(单列)布局视图。线性布局里面的子视图是通过添加的顺序建立约束和依赖关系的。
/// *根据排列的方向我们把子视图从上到下依次排列的线性布局视图称为垂直线性布局视图，而把子视图从左到右依次排列的线性布局视图则称为水平线性布局。
/// 垂直线性布局
/// +—––+
/// |   A   |
/// +—––+
/// |   B   |
/// +—––+  ⥥
/// |   C   |
/// +—––+
/// |  …  |
/// +—––+
/// 水平线性布局
/// +—–+—–+—–+—–+
/// |  A  |  B  |  C  | … |
/// +—–+—–+—–+—–+
/// ⥤
SWIFT_CLASS("_TtC10TangramKit14TGLinearLayout")
@interface TGLinearLayout : TGBaseLayout
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// 设置水平线性布局里面的基线对齐基准视图，所有其他子视图的基线都以这个为准。
/// 这个属性要和tg_gravity属性设置为TGGravity.vert.baseline配合使用。并且要求这个属性所指定的视图，必须具有font属性。
/// 目前支持具有font属性的有UILabel，UITextField,UITextView, UIButton几个系统控件。
@property (nonatomic, strong) UIView * _Null_unspecified tg_baselineBaseView SWIFT_DEPRECATED_OBJC("Swift property 'TGLinearLayout.tg_baselineBaseView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end




/// *路径布局类。路径布局通过坐标轴的设置，曲线路径函数方程，子视图中心点之间的距离三个要素来确定其中子视图的位置。因此通过路径布局可以实现一些非常酷炫的布局效果。
SWIFT_CLASS("_TtC10TangramKit12TGPathLayout")
@interface TGPathLayout : TGBaseLayout
/// 设置和获取布局视图中的原点视图，默认是nil。如果设置了原点视图则总会将原点视图作为布局视图中的最后一个子视图。原点视图将会显示在路径的坐标原点中心上，因此原点布局是不会参与在路径中的布局的。因为中心原点视图是布局视图中的最后一个子视图，而TGPathLayout重写了addSubview方法，因此可以正常的使用这个方法来添加子视图。
@property (nonatomic, strong) UIView * _Nullable tg_originView SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_originView' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回布局视图中所有在曲线路径中排列的子视图。如果设置了原点视图则返回subviews里面除最后一个子视图外的所有子视图，如果没有原点子视图则返回subviews
@property (nonatomic, readonly, copy) NSArray<UIView *> * _Nonnull tg_pathSubviews SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_pathSubviews' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置获取子视图距离的误差值。默认是0.5，误差越小则距离的精确值越大，误差最低值不能<=0。一般不需要调整这个值，只有那些要求精度非常高的场景才需要微调这个值,比如在一些曲线路径较短的情况下，通过调小这个值来子视图之间间距的精确计算。
@property (nonatomic) CGFloat tg_distanceError SWIFT_DEPRECATED_OBJC("Swift property 'TGPathLayout.tg_distanceError' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_beginSubviewPathPointWithFull:(BOOL)full SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_beginSubviewPathPoint(full:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)tg_endSubviewPathPoint SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_endSubviewPathPoint()' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建从某个子视图到另外一个子视图之间的路径点，返回NSValue数组，里面的值是CGPoint。
/// fromIndex指定开始的子视图的索引位置，toIndex指定结束的子视图的索引位置。如果有原点子视图时,这两个索引值不能算上原点子视图的索引值。
- (NSArray<NSValue *> * _Nullable)tg_getSubviewPathPointFromIndex:(NSInteger)fromIndex toIndex:(NSInteger)toIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_getSubviewPathPoint(fromIndex:toIndex:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 创建布局的曲线的路径。用户需要负责销毁返回的值。调用者可以用这个方法来获得曲线的路径，进行一些绘制的工作。
/// subviewCount:指定这个路径上子视图的数量的个数，如果设置为-1则是按照布局视图的子视图的数量来创建。需要注意的是如果布局视图的tg_spaceType为.flexed,.count的话则这个参数设置无效。
- (CGPathRef _Nonnull)tg_createPathWithSubviewCount:(NSInteger)subviewCount SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGPathLayout.tg_createPath(subviewCount:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)addSubview:(UIView * _Nonnull)view;
- (void)sendSubviewToBack:(UIView * _Nonnull)view;
- (void)willRemoveSubview:(UIView * _Nonnull)subview;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *相对布局是一种里面的子视图通过相互之间的约束和依赖来进行布局和定位的布局视图。
/// *相对布局里面的子视图的布局位置和添加的顺序无关，而是通过设置子视图的相对依赖关系来进行定位和布局的。
/// *相对布局提供和AutoLayout等价的功能。
SWIFT_CLASS("_TtC10TangramKit16TGRelativeLayout")
@interface TGRelativeLayout : TGBaseLayout
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end




/// *表格布局是一种里面的子视图可以像表格一样进行多行多列排列的布局视图。子视图添加到表格布局视图前必须先要建立并添加行子视图，然后再将列子视图添加到行子视图里面。
/// *表格里面的行子视图和列子视图的排列方向的概念是相对的，他根据表格布局方向的不同而不同。表格布局根据方向可分为垂直表格布局和水平表格布局。
/// *对于垂直表格布局来说，行子视图是从上到下依次排列的，而列子视图则是在行子视图里面从左到右依次排列。
/// *对于水平表格布局来说，行子视图是从左到右依次排列的，而列子视图则是在行子视图里面从上到下依次排列。
SWIFT_CLASS("_TtC10TangramKit13TGTableLayout")
@interface TGTableLayout : TGLinearLayout
/// 删除一行
- (void)tg_removeRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeRow(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两行的位置
- (void)tg_exchangeRow:(NSInteger)rowIndex1 with:(NSInteger)rowIndex2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeRow(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行对象
- (TGLinearLayout * _Nonnull)tg_rowViewAt:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_rowView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *返回行的数量
@property (nonatomic, readonly) NSInteger tg_rowCount SWIFT_DEPRECATED_OBJC("Swift property 'TGTableLayout.tg_rowCount' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 添加一个新的列。再添加一个新的列前必须要先添加行，对于垂直表格来说每一列是从左到右排列的，而对于水平表格来说每一列是从上到下排列的。
/// @colView:  列视图
/// @rowIndex: 指定要添加列的行的索引
- (void)tg_addCol:(UIView * _Nonnull)colView inRow:(NSInteger)rowIndex SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_addCol(_:inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 在指定的indexPath下插入一个新的列 IndexPath(row:1, col:1)
- (void)tg_insertCol:(UIView * _Nonnull)colView inIndexPath:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_insertCol(_:inIndexPath:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 删除一列
- (void)tg_removeCol:(NSIndexPath * _Nonnull)indexPath SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_removeCol(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 交换两个列视图，这两个列视图是可以跨行的
- (void)tg_exchangeCol:(NSIndexPath * _Nonnull)indexPath1 with:(NSIndexPath * _Nonnull)indexPath2 SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_exchangeCol(_:with:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回列视图
- (UIView * _Nonnull)tg_colViewAt:(NSIndexPath * _Nonnull)indexPath SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colView(at:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 返回某行的列的数量
- (NSInteger)tg_colCountInRow:(NSInteger)rowIndex SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_OBJC("Swift method 'TGTableLayout.tg_colCount(inRow:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@property (nonatomic) CGFloat tg_vspace;
@property (nonatomic) CGFloat tg_hspace;
/// *表格布局的addSubView被重新定义，是addCol:atRow的精简版本，表示插入当前行的最后一列
- (void)addSubview:(UIView * _Nonnull)view;
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
- (void)insertSubview:(UIView * _Nonnull)view belowSubview:(UIView * _Nonnull)siblingSubview;
- (void)insertSubview:(UIView * _Nonnull)view aboveSubview:(UIView * _Nonnull)siblingSubview;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end






@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 是否反方向浮动，默认是false表示正向浮动，正向浮动和反向浮动的意义根据所在的父浮动布局视图的方向的不同而不同：
/// 1.如果父视图是垂直浮动布局则默认正向浮动是向左浮动的，而反向浮动则是向右浮动。
/// 2.如果父视图是水平浮动布局则默认正向浮动是向上浮动的，而反向浮动则是向下浮动。
/// 下面是垂直浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F)：
/// |<–A– <—B—    -C->|
/// |<—–D–– -F-> –E–>|
/// 下面是水平浮动布局中的正向浮动和反向浮动的效果图(正向浮动:A,B,D; 反向浮动:C,E,F):
/// <hr/>
/// <h2>↑   ↑
/// |   |
/// A   |
/// |   D
/// |
/// ↑   |
/// B
/// |   F
/// ↓
/// |   |
/// C   E
/// ↓   ↓</h2>
@property (nonatomic) BOOL tg_reverseFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_reverseFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// *清除浮动，默认是false。这个属性的意义也跟父浮动布局视图的方向相关。如果设置为了清除浮动属性则表示本视图不会在浮动方向上紧跟在前一个浮动视图的后面，而是会另外新起一行或者一列来重新排列。tg_reverseFloat和tg_clearFloat这两个属性的定义是完全参考CSS样式表中浮动布局中的float和clear这两个属性。
/// 垂直浮动布局下的浮动和清除浮动
/// |<–A– <—B— <-C–|
/// |<––D—            |
/// |<–E– <—F–       |
/// |<—–G––          |
/// |      —I—> –H–>|
/// |                -J-> |
/// A(正向浮动);B(正向浮动);C(正向浮动);D(正向浮动);E(正向浮动);F(正向浮动);G(正向浮动，清除浮动);H(反向浮动);I(反向浮动);J(反向浮动，清除浮动)
@property (nonatomic) BOOL tg_clearFloat SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_clearFloat' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end




@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置开始位置的快捷方法。
/// \param point 左上角原点的位置
///
- (void)tg_origin:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_origin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// \param point 右下角的结束位置
///
- (void)tg_end:(CGPoint)point SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_end(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 同时设置tg_width和tg_height的简化方法。
/// \param size 宽度和高度值
///
- (void)tg_size:(CGSize)size SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_size(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 四周边距或者间距设置的简化方法
/// \param val 距离父视图四周的边距或者兄弟视图四周间距的值
///
- (void)tg_margin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_margin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 水平边距或者间距设置的简化方法
/// \param val 距离父视图左右水平边距或者兄弟视图左右间距的值
///
- (void)tg_horzMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_horzMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 垂直边距或者间距设置的简化方法
/// \param val 距离父视图上下垂直边距或者兄弟视图上下间距的值
///
- (void)tg_vertMargin:(CGFloat)val SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_vertMargin(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图的在父布局视图调用完评估尺寸的方法后，可以通过这个方法来获取评估的CGRect值。评估的CGRect值是在布局前评估计算的值，而frame则是视图真正完成布局后的真实的CGRect值。在调用这个方法前请先调用父布局视图的tg_sizeThatFits方法进行布局视图的尺寸评估，否则此方法返回的值未可知。这个方法主要用于在视图布局前而想得到其在父布局视图中的位置和尺寸的场景。
@property (nonatomic, readonly) CGRect tg_estimatedFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_estimatedFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 视图在父布局视图中布局完成后也就是视图的frame更新完成后执行的block，执行完block后会被重置为nil。通过在tg_layoutCompletedDo中我们可以得到这个视图真实的frame值,当然您也可以在里面进行其他业务逻辑的操作和属性的获取和更新。block方法中layout参数就是父布局视图，而v就是视图本身，block中这两个参数目的是为了防止循环引用的问题。
/// \param action 布局完成执行的action
///
- (void)tg_layoutCompletedDo:(void (^ _Nullable)(TGBaseLayout * _Nonnull, UIView * _Nonnull))action SWIFT_DEPRECATED_OBJC("Swift method 'UIView.tg_layoutCompletedDo(_:)' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end


@interface UIView (SWIFT_EXTENSION(TangramKit))
/// 设置视图不受布局父视图的布局约束控制和不再参与视图的布局，所有设置的其他扩展属性都将失效而必须用frame来设置视图的位置和尺寸，默认值是false。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_useFrame = true
/// 那么在布局完成后：
/// A.frame == {0, 0, 100, 100}
/// B.frame == {20,20,200,100}   //可以看出B并没有受到约束的限制，结果就是B设置的frame值。
/// C.frame == {0, 100,100,200}  //因为B不再参与布局了，所以C就往上移动了，由原来的150变为了100.
/// tg_useFrame的应用场景是某个视图虽然是布局视图的子视图但不想受到父布局视图的约束，而是可以通过frame进行自由位置和尺寸调整的场景。
@property (nonatomic) BOOL tg_useFrame SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_useFrame' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
/// 设置视图在进行布局时只会参与布局但不会真实的调整位置和尺寸，默认值是false。当设置为YES时会在布局时保留出视图的布局位置和布局尺寸的空间，但不会更新视图的位置和尺寸，也就是说只会占位但不会更新。因此你可以通过frame值来进行位置和尺寸的任意设置，而不会受到你的布局视图的影响。这个属性主要用于某些视图希望在布局视图中进行特殊处理和进行自定义的设置的场景。比如一个垂直线性布局下有A,B,C三个子视图设置如下：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// 正常情况下当布局完成后:
/// A.frame == {0,0,100,100}
/// B.frame == {0,100,100,50}  //可以看出即使B设置了frame值，但是因为布局约束属性优先级高所以对B设置的frame值是无效的。
/// C.frame == {0,150,100,200}
/// 而当我们设置如下时：
/// A.tg_size(width:100,height:100)
/// B.tg_size(width:100,height:50)
/// C.tg_size(width:100,height:200)
/// B.frame = CGRect(x:20,y:20,width:200,height:100)
/// B.tg_noLayout = true
/// 那么在布局完成后：
/// A.frame == {0,0,100,100}
/// B.frame == {20,20,200,100}  //可以看出虽然B参与了布局，但是并没有更新B的frame值，而是保持为通过frame设置的原始值。
/// C.frame == {0,150,100,200}  //因为B参与了布局，占用了50的高度，所以这里C的位置还是150，而不是100.
/// tg_useFrame和tg_noLayout的区别是：
/// <ol>
///   <li>
///     前者不会参与布局而必须要通过frame值进行设置，而后者则会参与布局但是不会将布局的结果更新到frame中。
///   </li>
///   <li>
///     当前者设置为true时后者的设置将无效，而后者的设置并不会影响前者的设置。
///   </li>
/// </ol>
/// tg_noLayout的应用场景是那些想在运行时动态调整某个视图的位置和尺寸，但是又不想破坏布局视图中其他子视图的布局结构的场景，也就是调整了视图的位置和尺寸，但是不会调整其他的兄弟子视图的位置和尺寸。
@property (nonatomic) BOOL tg_noLayout SWIFT_DEPRECATED_OBJC("Swift property 'UIView.tg_noLayout' uses '@objc' inference deprecated in Swift 4; add '@objc' to provide an Objective-C entrypoint");
@end



#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop

#endif

#endif
